{"version":3,"sources":["components/Tile.js","components/DebugTile.js","App.js","serviceWorker.js","index.js"],"names":["Tile","handleClick","bind","determineTileType","this","props","gameMode","tileValue","available","newGameState","handleGameState","rowIndex","colIndex","activePlayer","gameState","gameStateTranspose","updateMovesSoFar","updateState","black","console","log","humanIsBlack","tileStyle","Col","className","onClick","React","Component","DebugTile","white","possibleMoves","prunes","movesSoFar","App","state","inactivePlayer","blackPoints","whitePoints","availablePoints","debugBoards","debugMode","pruning","aiDepth","moves3","moves2","moves1","programTrace","setPlayer","checkTileOnRight","checkTileOnLeft","checkTileAbove","checkTileBelow","checkNorthEast","checkNorthWest","checkSouthEast","checkSouthWest","updateScore","handleGameMode","handleAI","checkForWin","bestPlay","minimax","createGameBoard","toggleColor","createDebugBoard","toggleDebug","alphabetaprune","togglePruning","handleDepth","handleDebugDepth","toggleProgramTrace","gameInfo","map","i","Row","key","j","push","coordinates","row","col","mode","setState","blackScore","whiteScore","availableSpots","length","winning","depth","debugDepth","result","player","alpha","beta","newGameStateTranspose","availables","nodeScore","heuristic","board","score","bestMove","moves","move","value","breadth","tiles","k","pruneBoard","minimaxResult","bestScore","tempGameState","tilesOnRightFromMeToRight","tileOnRightIsActivePlayer","firstInactivePlayerIndex","indexOf","firstBlankIndex","tilesOnLeftFromMeToLeft","tileOnLeftIsActivePlayer","tempGameStateTranspose","tilesAboveFromMeToTop","slice","reverse","tileAboveIsActivePlayer","tilesBelowFromMeToBottom","tileBelowIsActivePlayer","tilesFromMeToNorthEast","tileNorthEastIsActivePlayer","tilesFromMeToNorthWest","tileNorthWestIsActivePlayer","tilesFromMeToSouthEast","tileSouthEastIsActivePlayer","tilesFromMeToSouthWest","tileSouthWestIsActivePlayer","updatedGameState","updatedGameStateTranspose","downExistance","i_d","j_d","blankBelow","availableBelow","blankBeforeCurrentPlayer_d","availableBeforeCurrentPlayer_d","k_d","upExistance","i_u","j_u","blankAbove","availableAbove","blankBeforeCurrentPlayer_u","availableBeforeCurrentPlayer_u","k_u","leftExistance","i_l","j_l","blankLeft","availableLeft","blankBeforeCurrentPlayer_l","availableBeforeCurrentPlayer_l","k_l","rightExistance","i_r","j_r","blankRight","availableRight","blankBeforeCurrentPlayer_r","availableBeforeCurrentPlayer_r","k_r","nwDiagonalExistance","i_nwd","j_nwd","blankNW","availableNW","blankBeforeCurrentPlayer_nw","availableBeforeCurrentPlayer_nw","k_nwd","neDiagonalExistance","i_ned","j_ned","blankNE","availableNE","blankBeforeCurrentPlayer_ne","availableBeforeCurrentPlayer_ne","k_ned","seDiagonalExistance","i_sed","j_sed","blankSE","availableSE","blankBeforeCurrentPlayer_se","availableBeforeCurrentPlayer_se","k_sed","swDiagonalExistance","i_swd","j_swd","blankSW","availableSW","blankBeforeCurrentPlayer_sw","availableBeforeCurrentPlayer_sw","k_swd","index_i","index_j","scoreOfState","newScore","change","allMoves","style","margin","xs","item","index","width","height","float","Container","display","onTransitionEnd","position","top","left","backgroundColor","textAlign","padding","color","settings","marginTop","Button","variant","Form","Check","type","id","label","defaultChecked","custom","name","debugMode2","undefined","border","Fragment","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.6212f526.chunk.js","sourcesContent":["import React from 'react';\r\nimport '../App.css';\r\nimport { Col } from 'react-bootstrap'\r\n\r\nclass Tile extends React.Component{\r\n    constructor(){\r\n        super();\r\n        this.handleClick = this.handleClick.bind(this);\r\n        this.determineTileType = this.determineTileType.bind(this);\r\n    }\r\n\r\n    handleClick(){\r\n        if (this.props.gameMode === '2playergame' && this.props.tileValue === this.props.available ){\r\n           let newGameState = this.props.handleGameState(this.props.rowIndex, this.props.colIndex, this.props.activePlayer, this.props.gameState, this.props.gameStateTranspose);\r\n           this.props.updateMovesSoFar(newGameState);\r\n           this.props.updateState(newGameState.gameState, newGameState.gameStateTranspose, newGameState.activePlayer)\r\n        }\r\n        if (this.props.gameMode === 'aigame' && this.props.tileValue === this.props.available && this.props.activePlayer === this.props.black){\r\n            console.log('Human chose their play')\r\n            console.log('Row: ' + this.props.rowIndex + '; Col: ' + this.props.colIndex)\r\n            let newGameState = this.props.handleGameState(this.props.rowIndex, this.props.colIndex, this.props.activePlayer, this.props.gameState, this.props.gameStateTranspose);\r\n           console.log('Human played. The result follows')\r\n           console.log(newGameState.gameState);\r\n           this.props.updateMovesSoFar(newGameState);\r\n           this.props.updateState(newGameState.gameState, newGameState.gameStateTranspose, newGameState.activePlayer)\r\n        }\r\n        \r\n    }\r\n\r\n    determineTileType(){\r\n        let result;\r\n\r\n        if (this.props.tileValue === 1){\r\n            if (this.props.humanIsBlack){\r\n                result = 'player1'\r\n            }\r\n            else{\r\n                result = 'player2'\r\n            }\r\n        }\r\n        else if (this.props.tileValue === 2){\r\n            if (this.props.humanIsBlack){\r\n                result = 'player2'\r\n            }\r\n            else{\r\n                result = 'player1'\r\n            }\r\n        }\r\n        else if (this.props.tileValue=== this.props.available){\r\n            result = 'adjacentTile'\r\n        }\r\n        else {\r\n            result = 'empty'\r\n        }\r\n        return result;\r\n    }\r\n\r\n    render(){\r\n        let tileStyle = this.determineTileType();\r\n\r\n        return(\r\n            <Col className = 'mycol' onClick={this.handleClick}><div className = {tileStyle}></div></Col>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Tile;","import React from 'react';\r\nimport '../App.css';\r\nimport { Col } from 'react-bootstrap'\r\n\r\nclass DebugTile extends React.Component{\r\n    constructor(){\r\n        super();\r\n        this.determineTileType = this.determineTileType.bind(this)\r\n    }\r\n\r\n    determineTileType(){\r\n        let result;\r\n\r\n        if (this.props.tileValue === 1){\r\n            if (this.props.humanIsBlack){\r\n                result = 'player1'\r\n            }\r\n            else{\r\n                result = 'player2'\r\n            }\r\n        }\r\n        else if (this.props.tileValue === 2){\r\n            if (this.props.humanIsBlack){\r\n                result = 'player2'\r\n            }\r\n            else{\r\n                result = 'player1'\r\n            }\r\n        }\r\n        else if (this.props.tileValue=== this.props.available){\r\n            result = 'adjacentTile'\r\n        }\r\n        else {\r\n            result = 'empty'\r\n        }\r\n        return result;\r\n    }\r\n\r\n    render(){\r\n        let tileStyle = this.determineTileType();\r\n\r\n        return(\r\n            <Col className = 'mycol'><div className = {tileStyle}></div></Col>\r\n        )\r\n    }\r\n\r\n}\r\n\r\n\r\nexport default DebugTile;\r\n","/*\r\nJoshua Coriell\r\nTuesday, Novemeber 12\r\nCWID: 101-75-228\r\nAssignment #3 - Othello\r\n\r\nDescription:\r\nThis program implements Othello. You can play with two humans, or a human can play against an AI.\r\n*/\r\n\r\n\r\n\r\nimport React from 'react';\r\nimport './App.css';\r\nimport { Row, Container, Col, Form, Button } from 'react-bootstrap';\r\nimport Tile from './components/Tile';\r\nimport DebugTile from './components/DebugTile'\r\n\r\nvar black = 1;\r\nvar white = 2;\r\nconst available = 8;\r\nconst blank = 0;\r\nvar possibleMoves = [];\r\nvar prunes = [];\r\nvar movesSoFar = [];\r\n\r\nclass App extends React.Component{\r\n  constructor(){\r\n    super()\r\n    this.state = {\r\n      // 8 means valid move for current player, 1 is black, 2 white\r\n      gameState : [[0,0,0,0,0,0,0,0],\r\n                   [0,0,0,0,0,0,0,0],\r\n                   [0,0,0,available,0,0,0,0],\r\n                   [0,0,available,white,black,0,0,0],\r\n                   [0,0,0,black,white,available,0,0],\r\n                   [0,0,0,0,available,0,0,0],\r\n                   [0,0,0,0,0,0,0,0],\r\n                   [0,0,0,0,0,0,0,0],],\r\n      gameStateTranspose : [[0,0,0,0,0,0,0,0],\r\n                            [0,0,0,0,0,0,0,0],\r\n                            [0,0,0,available,0,0,0,0],\r\n                            [0,0,available,white,black,0,0,0],\r\n                            [0,0,0,black,white,available,0,0],\r\n                            [0,0,0,0,available,0,0,0],\r\n                            [0,0,0,0,0,0,0,0],\r\n                            [0,0,0,0,0,0,0,0],],\r\n      activePlayer : black,\r\n      inactivePlayer : white,\r\n      blackPoints: 2,\r\n      whitePoints: 2,\r\n      availablePoints: 4,\r\n      gameMode: 'menu',\r\n      humanIsBlack: true,\r\n      debugBoards: [],\r\n      debugMode: false,\r\n      pruning: false,\r\n      aiDepth: 3,\r\n      moves3: [],\r\n      moves2: [],\r\n      moves1: [],\r\n      programTrace: false,\r\n    }\r\n    this.setPlayer = this.setPlayer.bind(this);\r\n    this.handleGameState = this.handleGameState.bind(this);\r\n    this.checkTileOnRight = this.checkTileOnRight.bind(this);\r\n    this.checkTileOnLeft = this.checkTileOnLeft.bind(this);\r\n    this.checkTileAbove = this.checkTileAbove.bind(this);\r\n    this.checkTileBelow = this.checkTileBelow.bind(this);\r\n    this.checkNorthEast = this.checkNorthEast.bind(this);\r\n    this.checkNorthWest = this.checkNorthWest.bind(this);\r\n    this.checkSouthEast = this.checkSouthEast.bind(this);\r\n    this.checkSouthWest = this.checkSouthWest.bind(this);\r\n    this.updateScore = this.updateScore.bind(this);\r\n    this.handleGameMode = this.handleGameMode.bind(this);\r\n    this.handleAI = this.handleAI.bind(this);\r\n    this.checkForWin = this.checkForWin.bind(this);\r\n    this.bestPlay = this.bestPlay.bind(this);\r\n    this.minimax = this.minimax.bind(this);\r\n    this.updateState = this.updateState.bind(this);\r\n    this.createGameBoard = this.createGameBoard.bind(this);\r\n    this.toggleColor = this.toggleColor.bind(this);\r\n    this.createDebugBoard = this.createDebugBoard.bind(this);\r\n    this.toggleDebug = this.toggleDebug.bind(this)\r\n    this.alphabetaprune = this.alphabetaprune.bind(this);\r\n    this.togglePruning = this.togglePruning.bind(this);\r\n    this.handleDepth = this.handleDepth.bind(this);\r\n    this.handleDebugDepth = this.handleDebugDepth.bind(this);\r\n    this.updateMovesSoFar = this.updateMovesSoFar.bind(this);\r\n    this.toggleProgramTrace = this.toggleProgramTrace.bind(this);\r\n  }\r\n\r\n  // this functions takes the in all of the pertinent game information and creates an HTML element that is a board based on that element.\r\n  createDebugBoard(gameInfo){\r\n  \r\n    let result = gameInfo.gameState.map((i, rowIndex) => {\r\n    \r\n      return(\r\n          <Row className = 'myrow' key = {rowIndex}>\r\n            {i.map((j, colIndex) => {\r\n              return(\r\n                <DebugTile \r\n                  key = {colIndex}\r\n                  tileValue = {j} \r\n                  humanIsBlack = {this.state.humanIsBlack}\r\n                  available = {available}\r\n                  />\r\n              )\r\n              })\r\n            }\r\n          </Row>\r\n        )\r\n      })\r\n\r\n      return result\r\n \r\n  }\r\n\r\n  //this function takes in the game information, creates a board, and then puts that board in the array tracking all the moves previously executed.\r\n  updateMovesSoFar(gameInfo){\r\n    movesSoFar.push(this.createDebugBoard(gameInfo))\r\n  }\r\n\r\n  \r\n\r\n\r\n  // this function takes the gameinfo and simulates the AI playing. aftre the AI plays, it updates te game state.\r\n  handleAI(gameInfo){\r\n    console.log('Determining best play for AI...')\r\n    let coordinates = this.bestPlay(gameInfo)\r\n    let newGameState = this.handleGameState(coordinates.row, coordinates.col, gameInfo.activePlayer, gameInfo.gameState, gameInfo.gameStateTranspose)\r\n    console.log('AI played. The result follows')\r\n    console.log(newGameState.gameState);\r\n    this.updateMovesSoFar(newGameState);\r\n    this.updateState(newGameState.gameState, newGameState.gameStateTranspose, newGameState.activePlayer)\r\n  }\r\n\r\n  // this function is called when the game mode needs to change. the modes are 'menu', '2playergame', 'aigame' and 'gameover'\r\n  handleGameMode(mode){\r\n    this.setState({gameMode: mode})\r\n  }\r\n\r\n  //this function takes in the game state and outputs the number of points black and white each have. it always finds the number of spots labeled 'available' on the board\r\n  updateScore(gameState){\r\n    let blackScore = 0;\r\n    let whiteScore = 0;\r\n    let availableSpots = 0;\r\n    for (let i = 0; i < gameState.length; i++){\r\n      for (let j = 0; j < gameState[i].length; j++){\r\n        if (gameState[i][j] === black){blackScore++;}\r\n        if (gameState[i][j] === white){whiteScore++;}\r\n        if (gameState[i][j] === available){availableSpots++}\r\n      }\r\n    }\r\n\r\n\r\n    let result = {blackPoints: blackScore, whitePoints: whiteScore, availablePoints: availableSpots}\r\n    return result\r\n  }\r\n\r\n  // this function takes the score and determines who is winning. if the board is full it asks handle game mode to set the game to 'gameover'\r\n  checkForWin(blackScore, whiteScore, availableSpots){\r\n      let winning = null;\r\n        if (blackScore > whiteScore){\r\n          winning = 'Black';\r\n        }\r\n        if (whiteScore > blackScore){\r\n          winning = 'White';\r\n        }\r\n        if (blackScore === whiteScore){\r\n          winning = 'tie';\r\n        }\r\n        if (blackScore + whiteScore === 64 || availableSpots === 0){\r\n          this.handleGameMode('gameover')\r\n        }\r\n      return winning;\r\n  }\r\n\r\n  // this function is takes in the game info and outputs the coordinates of the best play for the AI\r\n  bestPlay(gameInfo){\r\n    /*\r\n    let inputRow;\r\n    let inputCol;\r\n    loop:\r\n    for (let i = 0; i < gameState.length; i++){\r\n      for (let j = 0; j < gameState[i].length; j++){\r\n        if(gameState[i][j] === available){\r\n          inputRow = i;\r\n          inputCol = j;\r\n          console.log('Best Play was at (Row = ' + inputRow + ', Col = ' + inputCol +')')\r\n          break loop;\r\n        }\r\n      }\r\n    }\r\n    let coordinates = {row: inputRow, col: inputCol};\r\n    */\r\n   possibleMoves = [];\r\n   prunes = []\r\n   let coordinates;\r\n   let depth = this.state.aiDepth;\r\n   this.setState({debugDepth: this.state.aiDepth})\r\n   if (this.state.pruning){\r\n    let alpha = -10000\r\n    let beta = 10000\r\n    \r\n    let result = this.alphabetaprune(gameInfo, gameInfo.activePlayer, depth, alpha, beta)\r\n    console.log('Row: ' + result.row + '; Col: ' + result.col)\r\n    coordinates = {row: result.row, col: result.col}\r\n   }\r\n\r\n   else { \r\n    let result = this.minimax(gameInfo, gameInfo.activePlayer, depth)\r\n    console.log('Row: ' + result.row + '; Col: ' + result.col)\r\n    coordinates = {row: result.row, col: result.col}\r\n   }\r\n\r\n    return coordinates;\r\n    \r\n  }\r\n\r\n  //this function performs minimax with alpha beta pruning. debugboards are also created here. it outputs the best move available.\r\n  alphabetaprune(gameInfo, player, depth, alpha, beta) {\r\n    let newGameState = gameInfo.gameState;\r\n    let newGameStateTranspose = gameInfo.gameStateTranspose;\r\n    // find the row and column of available spots to play in the incoming gamestate\r\n    let availables = [];\r\n    \r\n\r\n    for (let i = 0; i < newGameState.length; i++){\r\n      for (let j = 0; j < newGameState[i].length; j++){\r\n        if (newGameState[i][j] === available){\r\n          availables.push({row: i, col: j})\r\n        }\r\n      }\r\n    }\r\n\r\n    let nodeScore = this.updateScore(newGameState)\r\n    let heuristic = 100 * (nodeScore.whitePoints - nodeScore.blackPoints) / (nodeScore.whitePoints + nodeScore.blackPoints)\r\n\r\n    if (availables.length === 0 && nodeScore.whitePoints > nodeScore.blackPoints){\r\n      heuristic = 100\r\n    }\r\n    else if (availables.length === 0 && nodeScore.blackPoints > nodeScore.whitePoints){\r\n      heuristic = -100\r\n    }\r\n    else if (availables.length === 0){\r\n      heuristic = 0\r\n    }\r\n\r\n    if (this.state.debugMode){\r\n      possibleMoves.push({board: this.createDebugBoard(gameInfo), depth: depth, score: heuristic})\r\n    }\r\n\r\n    // check if you are at max depth.\r\n    if (depth === 0){\r\n      // if you are at max depth return the score of that node.\r\n     /* if (player === black){\r\n        let heuristic = 100 * (nodeScore.blackPoints - nodeScore.whitePoints) / (nodeScore.blackPoints + nodeScore.whitePoints)\r\n        return {score: heuristic}\r\n      }\r\n      if (player === white){*/\r\n        //let heuristic = 100 * (nodeScore.whitePoints - nodeScore.blackPoints) / (nodeScore.whitePoints + nodeScore.blackPoints)\r\n        return {score: heuristic}\r\n      //}\r\n          \r\n    }\r\n    else if (availables.length === 0){\r\n      return {score: heuristic}\r\n    }\r\n    \r\n    // create something that can store the scores for each move that is made (an array called moveScores = []). these will be evaluated later.\r\n    let moves = [];\r\n    // start a loop that runs through the available spots to play.\r\n    for (let i = 0; i < availables.length; i++){\r\n        // at the beginning of the loop, create an object that stores the row of the move, the col of the move, and the score that results from that move.\r\n        let move = {};\r\n        // set the row of the move object to row of the ith item in the array of available spots to play\r\n        // set the col of the move object to the col of the ith item in the array of available spots ot play\r\n        move.value = newGameState[availables[i].row][availables[i].col]\r\n        move.row = availables[i].row;\r\n        move.col = availables[i].col;\r\n        move.breadth = i;\r\n        \r\n        \r\n        let tiles = [];\r\n        for (let j = 0; j < newGameState.length; j++){\r\n          for (let k = 0; k < newGameState[j].length; k++){\r\n            tiles.push({row: j, col: k, value: newGameState[j][k]})\r\n          }\r\n        }\r\n \r\n      \r\n       \r\n        //simiulate a play by the current player\r\n        let result = this.handleGameState(availables[i].row, availables[i].col, player, newGameState, newGameStateTranspose)\r\n        if (this.state.debugMode){\r\n          var pruneBoard = this.createDebugBoard(result)\r\n        }\r\n\r\n        // if the player is the (ai) white player, \r\n        if (player === white){\r\n          //then store the result of calling minimax on the newGameState with the black player and one more level of depth\r\n          let minimaxResult = this.alphabetaprune(result, black, depth - 1, alpha, beta)\r\n          //also set the score of the move object to the score of the result of calling that minimax algorithm\r\n          move.score = minimaxResult.score\r\n\r\n          // set the board back to how it was if the play never happened. \r\n          for (let j = 0; j < tiles.length; j++){\r\n            newGameState[tiles[j].row][tiles[j].col] = tiles[j].value\r\n            newGameStateTranspose[tiles[j].col][tiles[j].row] = tiles[j].value\r\n          }\r\n          moves.push(move)\r\n          /// compare alpha to move.score and set alpha to whichever is larger\r\n          if (alpha < move.score){\r\n            alpha = move.score\r\n          }\r\n          /// if beta is less than alpha at this point, break out of the parent for loop\r\n          if (beta <= alpha){\r\n            if(this.state.debugMode){\r\n              prunes.push({depth: depth, breadth: move.breadth, board: pruneBoard})\r\n            }\r\n            break\r\n          }\r\n        }\r\n        // else, when it is not the AI's turn...\r\n        else {\r\n          //then store the result of calling minimax on the newGameState with the white player and one more level of depth\r\n          let minimaxResult = this.alphabetaprune(result, white, depth - 1, alpha, beta)\r\n          //also set the score of the move object to the score of the result of calling that minimax algorithm\r\n          move.score = minimaxResult.score\r\n\r\n          // set the board back to how it was if the play never happened. \r\n          for (let j = 0; j < tiles.length; j++){\r\n            newGameState[tiles[j].row][tiles[j].col] = tiles[j].value\r\n            newGameStateTranspose[tiles[j].col][tiles[j].row] = tiles[j].value\r\n          }\r\n\r\n          // moves.push(move) will add the score to the moves array for this iteration.\r\n          moves.push(move)\r\n\r\n          // compare beta to move.score and set beta to whichever is smaller.\r\n          if (beta > move.score){\r\n            beta = move.score\r\n          }\r\n          // if beta is less than alpha at this point, break out of the parent for loop\r\n          if (beta <= alpha){\r\n            if (this.state.debugMode){\r\n              prunes.push({depth: depth, breadth: move.breadth, board: pruneBoard})\r\n            }\r\n            break\r\n          }\r\n        }\r\n        // set the board back to how it was if the play never happened.    \r\n\r\n      \r\n        // moves.push(move) will add the score to the moves array for this iteration.\r\n        //moves.push(move)\r\n    }\r\n    // determine the best move to make.\r\n    let bestMove;\r\n    // if the player is white...\r\n    if (player === white){\r\n      let bestScore = -10000;\r\n      // loop through the moves array (all the scores). \r\n      for (let i = 0; i < moves.length; i++){\r\n        // if the score of the ith item is larger than the bestScore variable:\r\n        if (moves[i].score > bestScore){\r\n          // set bestScore to the score of that move.\r\n          bestScore = moves[i].score\r\n          // set bestMove = index of moves array\r\n          bestMove = i;\r\n        }\r\n      }\r\n    }\r\n    // if the player is black, chose the lowest score.\r\n    else {\r\n      // create a variable called bestScore and set it to a really large number (10000)\r\n      let bestScore = 10000;\r\n      for (let i = 0; i < moves.length; i++){\r\n        // if the score of the ith item is less than the bestScore variable:\r\n        if (moves[i].score < bestScore){\r\n          // set bestScore to the score of that move.\r\n          bestScore = moves[i].score\r\n          // set bestMove = index of moves array\r\n          bestMove = i;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return moves[bestMove];\r\n  }\r\n  \r\n\r\n\r\n\r\n\r\n  // this function is the same as the previous, but it does not do alpha beta pruning.\r\n  minimax(gameInfo, player, depth) {\r\n    let newGameState = gameInfo.gameState;\r\n    let newGameStateTranspose = gameInfo.gameStateTranspose;\r\n    // find the row and column of available spots to play in the incoming gamestate\r\n    let availables = [];\r\n    \r\n    for (let i = 0; i < newGameState.length; i++){\r\n      for (let j = 0; j < newGameState[i].length; j++){\r\n        if (newGameState[i][j] === available){\r\n          availables.push({row: i, col: j})\r\n        }\r\n      }\r\n    }\r\n\r\n    let nodeScore = this.updateScore(newGameState)\r\n    let heuristic = 100 * (nodeScore.whitePoints - nodeScore.blackPoints) / (nodeScore.whitePoints + nodeScore.blackPoints)\r\n    if (availables.length === 0 && nodeScore.whitePoints > nodeScore.blackPoints){\r\n      heuristic = 100\r\n    }\r\n    else if (availables.length === 0 && nodeScore.blackPoints > nodeScore.whitePoints){\r\n      heuristic = -100\r\n    }\r\n    else if (availables.length === 0){\r\n      heuristic = 0\r\n    }\r\n\r\n    // check if you are at max depth.\r\n    if(this.state.debugMode){\r\n      possibleMoves.push({board: this.createDebugBoard(gameInfo), depth: depth, score: heuristic})\r\n    }\r\n    if (depth === 0){\r\n      // if you are at max depth return the score of that node.\r\n     /* if (player === black){\r\n        let heuristic = 100 * (nodeScore.blackPoints - nodeScore.whitePoints) / (nodeScore.blackPoints + nodeScore.whitePoints)\r\n        return {score: heuristic}\r\n      }\r\n      if (player === white){*/\r\n        return {score: heuristic}\r\n      //}\r\n          \r\n    }\r\n    else if (availables.length === 0){\r\n\r\n        return {score: heuristic}\r\n    \r\n    }\r\n    \r\n    \r\n    // create something that can store the scores for each move that is made (an array called moveScores = []). these will be evaluated later.\r\n    let moves = [];\r\n    // start a loop that runs through the available spots to play.\r\n    for (let i = 0; i < availables.length; i++){\r\n        // at the beginning of the loop, create an object that stores the row of the move, the col of the move, and the score that results from that move.\r\n        let move = {};\r\n        // set the row of the move object to row of the ith item in the array of available spots to play\r\n        // set the col of the move object to the col of the ith item in the array of available spots ot play\r\n        move.value = newGameState[availables[i].row][availables[i].col]\r\n        move.row = availables[i].row;\r\n        move.col = availables[i].col;\r\n        \r\n        let tiles = [];\r\n        for (let j = 0; j < newGameState.length; j++){\r\n          for (let k = 0; k < newGameState[j].length; k++){\r\n            tiles.push({row: j, col: k, value: newGameState[j][k]})\r\n          }\r\n        }\r\n \r\n      \r\n       \r\n        //simiulate a play by the current player\r\n        let result = this.handleGameState(availables[i].row, availables[i].col, player, newGameState, newGameStateTranspose)\r\n        //move.board = this.createDebugBoard(result)\r\n        //move.breadth = i\r\n\r\n        \r\n\r\n        // if the player is the (ai) white player, \r\n        if (player === white){\r\n          //then store the result of calling minimax on the newGameState with the black player and one more level of depth\r\n          let minimaxResult = this.minimax(result, black, depth - 1)\r\n          //also set the score of the move object to the score of the result of calling that minimax algorithm\r\n          move.score = minimaxResult.score\r\n\r\n          // set the board back to how it was if the play never happened. \r\n          for (let j = 0; j < tiles.length; j++){\r\n            newGameState[tiles[j].row][tiles[j].col] = tiles[j].value\r\n            newGameStateTranspose[tiles[j].col][tiles[j].row] = tiles[j].value\r\n          }\r\n          \r\n          moves.push(move)\r\n          /// compare alpha to move.score and set alpha to whichever is larger\r\n\r\n        }\r\n        // else, when it is not the AI's turn...\r\n        else {\r\n          //then store the result of calling minimax on the newGameState with the white player and one more level of depth\r\n          let minimaxResult = this.minimax(result, white, depth - 1)\r\n          //also set the score of the move object to the score of the result of calling that minimax algorithm\r\n          move.score = minimaxResult.score\r\n\r\n          // set the board back to how it was if the play never happened. \r\n          for (let j = 0; j < tiles.length; j++){\r\n            newGameState[tiles[j].row][tiles[j].col] = tiles[j].value\r\n            newGameStateTranspose[tiles[j].col][tiles[j].row] = tiles[j].value\r\n          }\r\n\r\n          // moves.push(move) will add the score to the moves array for this iteration.\r\n          \r\n          moves.push(move)\r\n\r\n          // compare beta to move.score and set beta to whichever is smaller.\r\n        }\r\n        // set the board back to how it was if the play never happened.    \r\n\r\n      \r\n        // moves.push(move) will add the score to the moves array for this iteration.\r\n        //moves.push(move)\r\n    }\r\n    // determine the best move to make.\r\n    let bestMove;\r\n    // if the player is white...\r\n    if (player === white){\r\n      let bestScore = -10000;\r\n      // loop through the moves array (all the scores). \r\n      for (let i = 0; i < moves.length; i++){\r\n        // if the score of the ith item is larger than the bestScore variable:\r\n        if (moves[i].score > bestScore){\r\n          // set bestScore to the score of that move.\r\n          bestScore = moves[i].score\r\n          // set bestMove = index of moves array\r\n          bestMove = i;\r\n        }\r\n      }\r\n    }\r\n    // if the player is black, chose the lowest score.\r\n    else {\r\n      // create a variable called bestScore and set it to a really large number (10000)\r\n      let bestScore = 10000;\r\n      for (let i = 0; i < moves.length; i++){\r\n        // if the score of the ith item is less than the bestScore variable:\r\n        if (moves[i].score < bestScore){\r\n          // set bestScore to the score of that move.\r\n          bestScore = moves[i].score\r\n          // set bestMove = index of moves array\r\n          bestMove = i;\r\n        }\r\n      }\r\n    }\r\n    /*\r\n  \r\n    let key = 'moves' + depth\r\n    \r\n    if (key === 'moves3'){\r\n      this.setState({[key]: [...this.state.moves3, moves]})\r\n    }\r\n    if (key === 'moves2'){\r\n      this.setState({[key]: [...this.state.moves2, moves]})\r\n    }\r\n    if (key === 'moves1'){\r\n      this.setState({[key]: [...this.state.moves1, moves]})\r\n    }*/\r\n    return moves[bestMove];\r\n    \r\n  }\r\n  \r\n\r\n  //this function checks for available moves to the right of tile x with rowIndex and colIndex\r\n  checkTileOnRight(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    // if you're on the edge, don't check the next tile.\r\n    if (colIndex === 7){return false}\r\n    // if you're not on the edge, see if the tile on the right is the same color as the person who just played and if the upcoming player has a piece in this row, return true.\r\n    else {\r\n      let tilesOnRightFromMeToRight = [];\r\n      let i = rowIndex;\r\n      let j = colIndex + 1;\r\n      while (j <= 7){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesOnRightFromMeToRight.push(result);\r\n        j++;\r\n      } \r\n      let tileOnRightIsActivePlayer = (tilesOnRightFromMeToRight[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesOnRightFromMeToRight.indexOf(inactivePlayer)\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let firstBlankIndex = tilesOnRightFromMeToRight.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      let inactivePlayerExistsInTilesOnRight = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      if (tileOnRightIsActivePlayer && inactivePlayerExistsInTilesOnRight && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n\r\n  }\r\n}\r\n\r\n  //this function determines the availability of tiles to the left of tile x\r\n  checkTileOnLeft(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    // if you're on the edge, don't check the previous tile.\r\n    if (colIndex === 0){return false}\r\n    else{\r\n      let tilesOnLeftFromMeToLeft = [];\r\n      let i = rowIndex;\r\n      let j = colIndex - 1;\r\n      while (j >= 0){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesOnLeftFromMeToLeft.push(result);\r\n        j--;\r\n      } \r\n      let tileOnLeftIsActivePlayer = (tilesOnLeftFromMeToLeft[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesOnLeftFromMeToLeft.indexOf(inactivePlayer)\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let firstBlankIndex = tilesOnLeftFromMeToLeft.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      let inactivePlayerExistsInTilesOnLeft = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      if (tileOnLeftIsActivePlayer && inactivePlayerExistsInTilesOnLeft && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n\r\n    }\r\n \r\n  \r\n  }\r\n\r\n  //this function determines the availability of tiles above a given tile x\r\n  checkTileAbove(rowIndex, colIndex, activePlayer, tempGameStateTranspose){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    // if you're on the edge, don't check above.\r\n    if (rowIndex === 0){return false}\r\n    else{\r\n      let tilesAboveFromMeToTop = tempGameStateTranspose[colIndex].slice(0, rowIndex).reverse()  //creates an array of the tile on the right of the current one.\r\n      let tileAboveIsActivePlayer = (tilesAboveFromMeToTop[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesAboveFromMeToTop.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesAboveFromMeToTop.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInTilesAbove = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileAboveIsActivePlayer && inactivePlayerExistsInTilesAbove && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n\r\n\r\n    }\r\n  }\r\n\r\n  //this function determines the availability of tiles below a given tile x\r\n  checkTileBelow(rowIndex, colIndex, activePlayer, tempGameStateTranspose){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    // if you're on the edge, don't check above.\r\n    if (rowIndex === 7){return false}\r\n    else{\r\n      let tilesBelowFromMeToBottom = tempGameStateTranspose[colIndex].slice(rowIndex + 1)\r\n      let tileBelowIsActivePlayer = (tilesBelowFromMeToBottom[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesBelowFromMeToBottom.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesBelowFromMeToBottom.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInTilesBelow = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileBelowIsActivePlayer && inactivePlayerExistsInTilesBelow && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n      \r\n    }\r\n  }\r\n\r\n  //this function determines the availability of tiles in the diagonal that extends up and to the right of a given tile x\r\n  checkNorthEast(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    if (rowIndex ===  0 || colIndex === 7){return false}\r\n    else{\r\n      let tilesFromMeToNorthEast = [];\r\n      let i = rowIndex - 1;\r\n      let j = colIndex + 1;\r\n      while (i >= 0 && j <= 7){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesFromMeToNorthEast.push(result);\r\n        i--;\r\n        j++;\r\n      }\r\n      let tileNorthEastIsActivePlayer = (tilesFromMeToNorthEast[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesFromMeToNorthEast.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesFromMeToNorthEast.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInNorthEastTiles = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileNorthEastIsActivePlayer && inactivePlayerExistsInNorthEastTiles && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n    }\r\n\r\n  }\r\n\r\n//this function determines the availability of tiles in the diagonal that extends up and to the left of a given tile x\r\n  checkNorthWest(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    if (rowIndex ===  0 || colIndex === 0){return false}\r\n    else{\r\n      let tilesFromMeToNorthWest = [];\r\n      let i = rowIndex - 1;\r\n      let j = colIndex - 1;\r\n      while (i >= 0 && j >= 0){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesFromMeToNorthWest.push(result);\r\n        i--;\r\n        j--;\r\n      }\r\n      let tileNorthWestIsActivePlayer = (tilesFromMeToNorthWest[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesFromMeToNorthWest.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesFromMeToNorthWest.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInNorthWestTiles = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileNorthWestIsActivePlayer && inactivePlayerExistsInNorthWestTiles && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n    }\r\n\r\n  }\r\n\r\n  //this function determines the availability of tiles in the diagonal that extends down and to the right of a given tile x\r\n  checkSouthEast(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    if (rowIndex ===  7 || colIndex === 7){return false}\r\n    else{\r\n      let tilesFromMeToSouthEast = [];\r\n      let i = rowIndex + 1;\r\n      let j = colIndex + 1;\r\n      while (i <= 7 && j <= 7){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesFromMeToSouthEast.push(result);\r\n        i++;\r\n        j++;\r\n      }\r\n      let tileSouthEastIsActivePlayer = (tilesFromMeToSouthEast[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesFromMeToSouthEast.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesFromMeToSouthEast.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInSouthEastTiles = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileSouthEastIsActivePlayer && inactivePlayerExistsInSouthEastTiles && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n    }\r\n\r\n  }\r\n\r\n  //this function determines the availability of tiles in the diagonal that extends down and to the left of a given tile x\r\n  checkSouthWest(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    if (rowIndex ===  7 || colIndex === 0){return false}\r\n    else{\r\n      let tilesFromMeToSouthWest = [];\r\n      let i = rowIndex + 1;\r\n      let j = colIndex - 1;\r\n      while (i <= 7 && j >= 0){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesFromMeToSouthWest.push(result);\r\n        i++;\r\n        j--;\r\n      }\r\n      let tileSouthWestIsActivePlayer = (tilesFromMeToSouthWest[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesFromMeToSouthWest.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesFromMeToSouthWest.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInSouthWestTiles = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileSouthWestIsActivePlayer && inactivePlayerExistsInSouthWestTiles && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n    }\r\n \r\n  }\r\n\r\n // this function switches the player who is currently active\r\n  setPlayer(activePlayer){\r\n    if(activePlayer === black){\r\n      this.setState({activePlayer: white, inactivePlayer: black})\r\n    }\r\n    else if (activePlayer === white){\r\n      this.setState({activePlayer: black, inactivePlayer: white})\r\n    } \r\n  }\r\n\r\n\r\n  //this function updates the game state by assigning the player that just made a move to the appropriate square.\r\n  handleGameState(rowIndex, colIndex, activePlayer, gameState, gameStateTranspose){\r\n     //Initialize Updated Game State and it's transpose\r\n     let updatedGameState = gameState;\r\n     let updatedGameStateTranspose = gameStateTranspose;\r\n     let inactivePlayer = (activePlayer === black ? white : black)\r\n\r\n    // this block of code determines the color of pieces below the tile where the active player just played\r\n    let downExistance = [];\r\n    let i_d = rowIndex + 1;\r\n    let j_d = colIndex;\r\n    while (i_d <= 7){\r\n      downExistance.push(updatedGameState[i_d][j_d])\r\n      i_d++;\r\n    }\r\n   \r\n    let blankBelow = downExistance.indexOf(blank) !== -1 ? true : false\r\n    let availableBelow = downExistance.indexOf(available) !== -1 ? true : false\r\n    let blankBeforeCurrentPlayer_d = downExistance.indexOf(blank) < downExistance.indexOf(activePlayer) ? true : false\r\n    let availableBeforeCurrentPlayer_d = downExistance.indexOf(available) < downExistance.indexOf(activePlayer) ? true : false\r\n    if (blankBelow && blankBeforeCurrentPlayer_d){\r\n      downExistance = [];\r\n    }\r\n    if ( availableBelow && availableBeforeCurrentPlayer_d ){\r\n      downExistance = [];\r\n    }\r\n\r\n    if (downExistance.indexOf(activePlayer) !== -1){\r\n     let i_d = rowIndex + 1;\r\n     let j_d = colIndex;\r\n     let k_d = 0;\r\n     while (i_d <= 7 && downExistance[k_d] !== activePlayer && downExistance[k_d] === inactivePlayer ){\r\n       updatedGameState[i_d][j_d] = activePlayer;\r\n       updatedGameStateTranspose[j_d][i_d] = activePlayer;\r\n       i_d++;\r\n       k_d++;\r\n     }\r\n    }\r\n\r\n\r\n    // this block of code determines the color of pieces above the tile where the active player just played\r\n    let upExistance = [];\r\n    let i_u = rowIndex - 1 ;\r\n    let j_u = colIndex;\r\n    while (i_u >= 0){\r\n      upExistance.push(this.state.gameState[i_u][j_u])\r\n      i_u--;\r\n    }\r\n    \r\n    let blankAbove = upExistance.indexOf(blank) !== -1 ? true : false\r\n    let availableAbove = upExistance.indexOf(available) !== -1 ? true : false\r\n    let blankBeforeCurrentPlayer_u = upExistance.indexOf(blank) < upExistance.indexOf(activePlayer) ? true : false\r\n    let availableBeforeCurrentPlayer_u = upExistance.indexOf(available) < upExistance.indexOf(activePlayer) ? true : false\r\n    if ( blankAbove && blankBeforeCurrentPlayer_u ){\r\n      upExistance = [];\r\n    }\r\n    if ( availableAbove && availableBeforeCurrentPlayer_u ){\r\n      upExistance = [];\r\n    }\r\n    \r\n    if (upExistance.indexOf(activePlayer) !== -1){\r\n     let i_u = rowIndex - 1;\r\n     let j_u = colIndex;\r\n     let k_u = 0;\r\n     while (i_u >= 0 && upExistance[k_u] !== activePlayer && upExistance[k_u] === inactivePlayer){\r\n       updatedGameState[i_u][j_u] = activePlayer;\r\n       updatedGameStateTranspose[j_u][i_u] = activePlayer;\r\n       i_u--;\r\n       k_u++;\r\n     }\r\n    }\r\n\r\n    // this block of code determines the color of pieces to the left of the tile where the active player just played\r\n    let leftExistance = [];\r\n    let i_l = rowIndex;\r\n    let j_l = colIndex - 1;\r\n    while (j_l >= 0){\r\n      leftExistance.push(updatedGameState[i_l][j_l])\r\n      j_l--;\r\n    }\r\n\r\n    let blankLeft = leftExistance.indexOf(blank) !== -1 ? true : false\r\n    let availableLeft = leftExistance.indexOf(available) !== -1 ? true : false\r\n    let blankBeforeCurrentPlayer_l = leftExistance.indexOf(blank) < leftExistance.indexOf(activePlayer) ? true : false\r\n    let availableBeforeCurrentPlayer_l = leftExistance.indexOf(available) < leftExistance.indexOf(activePlayer) ? true : false\r\n    if ( blankLeft && blankBeforeCurrentPlayer_l ){\r\n      leftExistance = [];\r\n    }\r\n    if ( availableLeft && availableBeforeCurrentPlayer_l ){\r\n      leftExistance = [];\r\n    }\r\n\r\n    if (leftExistance.indexOf(activePlayer) !== -1){\r\n     let i_l = rowIndex;\r\n     let j_l = colIndex - 1;\r\n     let k_l = 0;\r\n     while (j_l >= 0 && leftExistance[k_l] !== activePlayer && leftExistance[k_l] === inactivePlayer){\r\n       updatedGameState[i_l][j_l] = activePlayer;\r\n       updatedGameStateTranspose[j_l][i_l] = activePlayer;\r\n       j_l--;\r\n       k_l++;\r\n     }\r\n    }\r\n\r\n    // this block of code determines the color of pieces to the right of the tile where the active player just played\r\n     let rightExistance = [];\r\n     let i_r = rowIndex;\r\n     let j_r = colIndex + 1;\r\n     while (j_r <= 7){\r\n       rightExistance.push(updatedGameState[i_r][j_r])\r\n       j_r++;\r\n     }\r\n\r\n     let blankRight = rightExistance.indexOf(blank) !== -1 ? true : false\r\n     let availableRight = rightExistance.indexOf(available) !== -1 ? true : false\r\n     let blankBeforeCurrentPlayer_r = rightExistance.indexOf(blank) < rightExistance.indexOf(activePlayer) ? true : false\r\n     let availableBeforeCurrentPlayer_r = rightExistance.indexOf(available) < rightExistance.indexOf(activePlayer) ? true : false\r\n     if ( blankRight && blankBeforeCurrentPlayer_r ){\r\n       rightExistance = [];\r\n     }\r\n     if ( availableRight && availableBeforeCurrentPlayer_r ){\r\n       rightExistance = [];\r\n     }\r\n\r\n\r\n     if (rightExistance.indexOf(activePlayer) !== -1){\r\n      let i_r = rowIndex;\r\n      let j_r = colIndex + 1;\r\n      let k_r = 0;\r\n      while (j_r <= 7 && rightExistance[k_r] !== activePlayer && rightExistance[k_r] === inactivePlayer){\r\n        updatedGameState[i_r][j_r] = activePlayer;\r\n        updatedGameStateTranspose[j_r][i_r] = activePlayer;\r\n        j_r++;\r\n        k_r++;\r\n      }\r\n     }\r\n\r\n     // this block of code determines the color of pieces up and to the right of the tile where the active player just played\r\n     let nwDiagonalExistance = [];\r\n     let i_nwd = rowIndex - 1;\r\n     let j_nwd = colIndex + 1;\r\n     while (i_nwd >= 0 && j_nwd <= 7){\r\n       nwDiagonalExistance.push(updatedGameState[i_nwd][j_nwd]);\r\n       i_nwd--;\r\n       j_nwd++;\r\n     }\r\n\r\n     let blankNW = nwDiagonalExistance.indexOf(blank) !== -1 ? true : false\r\n     let availableNW = nwDiagonalExistance.indexOf(available) !== -1 ? true : false\r\n     let blankBeforeCurrentPlayer_nw = nwDiagonalExistance.indexOf(blank) < nwDiagonalExistance.indexOf(activePlayer) ? true : false\r\n     let availableBeforeCurrentPlayer_nw = nwDiagonalExistance.indexOf(available) < nwDiagonalExistance.indexOf(activePlayer) ? true : false\r\n     if ( blankNW && blankBeforeCurrentPlayer_nw ){\r\n       nwDiagonalExistance = [];\r\n     }\r\n     if ( availableNW && availableBeforeCurrentPlayer_nw ){\r\n       nwDiagonalExistance = [];\r\n     }\r\n\r\n\r\n     if (nwDiagonalExistance.indexOf(activePlayer) !== -1){\r\n      let i_nwd = rowIndex - 1;\r\n      let j_nwd = colIndex + 1;\r\n      let k_nwd = 0;\r\n      while (i_nwd >= 0 && j_nwd <= 7 && nwDiagonalExistance[k_nwd] !== activePlayer && nwDiagonalExistance[k_nwd] === inactivePlayer){\r\n        updatedGameState[i_nwd][j_nwd] = activePlayer;\r\n        updatedGameStateTranspose[j_nwd][i_nwd] = activePlayer;\r\n        i_nwd--;\r\n        j_nwd++;\r\n        k_nwd++;\r\n      }\r\n     }\r\n\r\n      // this block of code determines the color of pieces up and to the left of the tile where the active player just played\r\n      let neDiagonalExistance = [];\r\n      let i_ned = rowIndex - 1;\r\n      let j_ned = colIndex - 1; \r\n      while (i_ned >= 0 && j_ned >= 0){\r\n        neDiagonalExistance.push(updatedGameState[i_ned][j_ned]);\r\n        i_ned--;\r\n        j_ned--;\r\n      }\r\n\r\n      let blankNE = neDiagonalExistance.indexOf(blank) !== -1 ? true : false\r\n      let availableNE = neDiagonalExistance.indexOf(available) !== -1 ? true : false\r\n      let blankBeforeCurrentPlayer_ne = neDiagonalExistance.indexOf(blank) < neDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      let availableBeforeCurrentPlayer_ne = neDiagonalExistance.indexOf(available) < neDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      if ( blankNE && blankBeforeCurrentPlayer_ne ){\r\n        neDiagonalExistance = [];\r\n      }\r\n      if ( availableNE && availableBeforeCurrentPlayer_ne ){\r\n        neDiagonalExistance = [];\r\n      }\r\n\r\n\r\n      if (neDiagonalExistance.indexOf(activePlayer) !== -1){\r\n        let i_ned = rowIndex - 1;\r\n        let j_ned = colIndex - 1;\r\n        let k_ned = 0;\r\n        while (i_ned >= 0 && j_ned >= 0 && neDiagonalExistance[k_ned] !== activePlayer && neDiagonalExistance[k_ned] === inactivePlayer){\r\n          updatedGameState[i_ned][j_ned] = activePlayer;\r\n          updatedGameStateTranspose[j_ned][i_ned] = activePlayer;\r\n          i_ned--;\r\n          j_ned--;\r\n          k_ned++;\r\n        }\r\n      }\r\n    \r\n      // this block of code determines the color of pieces down and to the right of the tile where the active player just played\r\n      let seDiagonalExistance = [];\r\n      let i_sed = rowIndex + 1;\r\n      let j_sed = colIndex + 1;\r\n      while (i_sed <= 7 && j_sed <= 7){\r\n        seDiagonalExistance.push(updatedGameState[i_sed][j_sed]);\r\n        i_sed++;\r\n        j_sed++;\r\n      }\r\n\r\n\r\n      let blankSE = seDiagonalExistance.indexOf(blank) !== -1 ? true : false\r\n      let availableSE = seDiagonalExistance.indexOf(available) !== -1 ? true : false\r\n      let blankBeforeCurrentPlayer_se = seDiagonalExistance.indexOf(blank) < seDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      let availableBeforeCurrentPlayer_se = seDiagonalExistance.indexOf(available) < seDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      if ( blankSE && blankBeforeCurrentPlayer_se ){\r\n        seDiagonalExistance = [];\r\n      }\r\n      if ( availableSE && availableBeforeCurrentPlayer_se ){\r\n        seDiagonalExistance = [];\r\n      }\r\n\r\n\r\n      if (seDiagonalExistance.indexOf(activePlayer) !== -1){\r\n        let i_sed = rowIndex + 1;\r\n        let j_sed = colIndex + 1;\r\n        let k_sed = 0;\r\n        while (i_sed <= 7 && j_sed <= 7 && seDiagonalExistance[k_sed] !== activePlayer && seDiagonalExistance[k_sed] === inactivePlayer){\r\n          updatedGameState[i_sed][j_sed] = activePlayer;\r\n          updatedGameStateTranspose[j_sed][i_sed] = activePlayer;\r\n          i_sed++;\r\n          j_sed++;\r\n          k_sed++;\r\n        }\r\n      }\r\n  \r\n      // this block of code determines the color of pieces down and to the left of the tile where the active player just played\r\n      let swDiagonalExistance = [];\r\n      let i_swd = rowIndex + 1;\r\n      let j_swd = colIndex - 1;\r\n      while (i_swd <= 7 && j_swd >= 0){\r\n        swDiagonalExistance.push(updatedGameState[i_swd][j_swd]);\r\n        i_swd++;\r\n        j_swd--;\r\n      }\r\n\r\n\r\n      let blankSW = swDiagonalExistance.indexOf(blank) !== -1 ? true : false\r\n      let availableSW = swDiagonalExistance.indexOf(available) !== -1 ? true : false\r\n      let blankBeforeCurrentPlayer_sw = swDiagonalExistance.indexOf(blank) < swDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      let availableBeforeCurrentPlayer_sw = swDiagonalExistance.indexOf(available) < swDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      if ( blankSW && blankBeforeCurrentPlayer_sw ){\r\n        swDiagonalExistance = [];\r\n      }\r\n      if ( availableSW && availableBeforeCurrentPlayer_sw ){\r\n        swDiagonalExistance = [];\r\n      }\r\n\r\n\r\n      if (swDiagonalExistance.indexOf(activePlayer) !== -1){\r\n        let i_swd = rowIndex + 1;\r\n        let j_swd = colIndex - 1;\r\n        let k_swd = 0;\r\n        while (i_swd <= 7 && j_swd >= 0 && swDiagonalExistance[k_swd] !== activePlayer && swDiagonalExistance[k_swd] === inactivePlayer){\r\n          updatedGameState[i_swd][j_swd] = activePlayer;\r\n          updatedGameStateTranspose[j_swd][i_swd] = activePlayer;\r\n          i_swd++;\r\n          j_swd--;\r\n          k_swd++;\r\n        }\r\n      }\r\n\r\n\r\n     //Set the clicked block to whichever player clicked it.\r\n      updatedGameState[rowIndex][colIndex] = activePlayer;\r\n      updatedGameStateTranspose[colIndex][rowIndex] = activePlayer;\r\n\r\n\r\n     //Remove tiles that were previously labeled as available\r\n     updatedGameState = updatedGameState.map(i => i.map(j => j === available ? j = 0 : j))\r\n     updatedGameStateTranspose = updatedGameStateTranspose.map(i => i.map(j => j === available ? j = 0 : j))\r\n\r\n     let tempGameState = updatedGameState\r\n     let tempGameStateTranspose = updatedGameStateTranspose\r\n\r\n     //Go through each tile and determine if it should be available for the next player.\r\n     updatedGameState = updatedGameState.map((i, index_i) => {\r\n       return(\r\n          i.map((j, index_j) => {\r\n            \r\n            return(\r\n              (j === blank || j === available) &&\r\n              ( this.checkTileOnRight(index_i, index_j, activePlayer, tempGameState) || this.checkTileOnLeft(index_i, index_j, activePlayer, tempGameState) || \r\n               this.checkTileAbove(index_i, index_j, activePlayer, tempGameStateTranspose) || this.checkTileBelow(index_i, index_j, activePlayer, tempGameStateTranspose) || \r\n               this.checkNorthEast(index_i, index_j, activePlayer, tempGameState) || this.checkNorthWest(index_i, index_j, activePlayer, tempGameState) ||\r\n               this.checkSouthEast(index_i, index_j, activePlayer, tempGameState) || this.checkSouthWest(index_i, index_j, activePlayer, tempGameState) ) ? \r\n              j = 8 : j\r\n              )\r\n          })\r\n       ) \r\n      })\r\n\r\n      for (let i = 0; i < updatedGameStateTranspose.length; i++){\r\n        for (let j = 0; j < updatedGameStateTranspose[i].length; j++){\r\n          updatedGameStateTranspose[i][j] = updatedGameState[j][i];\r\n        }\r\n      }\r\n    \r\n     let scoreOfState = this.updateScore(gameState)\r\n     let result = {gameState: updatedGameState, gameStateTranspose: updatedGameStateTranspose, activePlayer: activePlayer, scoreOfState: scoreOfState};\r\n  \r\n\r\n     return result\r\n  }\r\n\r\n  // update the App's state. Called after a player players and after the game board is handled. this causes the render method to run since it updates the state\r\n  updateState(updatedGameState, updatedGameStateTranspose, activePlayer){\r\n    let newScore = this.updateScore(updatedGameState)\r\n    this.checkForWin(newScore.blackPoints, newScore.whitePoints, newScore.availablePoints)\r\n    this.setState({gameState: updatedGameState, \r\n                   gameStateTranspose: updatedGameStateTranspose,\r\n                   blackPoints: newScore.blackPoints,\r\n                   whitePoints: newScore.whitePoints,\r\n                   availablePoints: newScore.availablePoints})\r\n    this.setPlayer(activePlayer);\r\n  }\r\n\r\n  // creates the gameboard when called. this is called from within the render method. the render method runs anytime the state is updated.\r\n  createGameBoard(gameState){\r\n    let result = gameState.map((i, rowIndex) => {\r\n    \r\n      return(\r\n          <Row className = 'myrow' key = {rowIndex}>\r\n            {i.map((j, colIndex) => {\r\n              return(\r\n                <Tile \r\n                  key = {colIndex}\r\n                  tileValue = {j} \r\n                  handleGameState = {this.handleGameState}\r\n                  rowIndex = {rowIndex} \r\n                  colIndex = {colIndex} \r\n                  activePlayer = {this.state.activePlayer}\r\n                  handleAI = {this.handleAI}\r\n                  gameMode = {this.state.gameMode}\r\n                  gameState = {this.state.gameState}\r\n                  gameStateTranspose = {this.state.gameStateTranspose}\r\n                  updateState = {this.updateState}\r\n                  black = {black}\r\n                  white = {white}\r\n                  available = {available}\r\n                  humanIsBlack = {this.state.humanIsBlack}\r\n                  updateMovesSoFar = {this.updateMovesSoFar}\r\n\r\n              \r\n                  />\r\n              )\r\n              })\r\n            }\r\n          </Row>\r\n        )\r\n      })\r\n\r\n      return result\r\n  }\r\n  \r\n  //toggle the colors of the players\r\n  toggleColor(){\r\n    this.setState({humanIsBlack: !this.state.humanIsBlack})\r\n  }\r\n\r\n  //turns the debug mode on/off\r\n  toggleDebug(){\r\n    this.setState({debugMode: !this.state.debugMode})\r\n  }\r\n\r\n  //turns alpha beta pruning on/off\r\n  togglePruning(){\r\n    this.setState({pruning: !this.state.pruning})\r\n  }\r\n\r\n  //turns the program trace view on and off\r\n  toggleProgramTrace(){\r\n    this.setState({programTrace: !this.state.programTrace})\r\n  }\r\n\r\n  //adjusts the depth of the AI\r\n  handleDepth(depth){\r\n    this.setState({aiDepth: depth})\r\n  }\r\n\r\n  //handles the depth of the debug mode\r\n  handleDebugDepth(change){\r\n    let depth = this.state.debugDepth + change;\r\n    this.setState({debugDepth: depth})\r\n  }\r\n\r\n\r\n  // this function is called anytime the state of the App updates.\r\n  render(){\r\n\r\n    // stores the game's info\r\n    let gameInfo = {  \r\n                      gameState: this.state.gameState, \r\n                      gameStateTranspose: this.state.gameStateTranspose, \r\n                      activePlayer: this.state.activePlayer, \r\n                      scoreOfState: \r\n                        {\r\n                          blackPoints: this.state.blackPoints, \r\n                          whitePoints: this.state.whitePoints, \r\n                          availablePoints: this.state.availablePoints\r\n                        }\r\n                    }\r\n    \r\n    // stores the HTML element that displays the program trace               \r\n    let allMoves = <Row style={{margin: '20px'}}>\r\n                        <Col xs = {12}>\r\n                        <h5>Game Trace</h5>\r\n                        {movesSoFar.map((item, index) => {    \r\n                            return(                 \r\n                            <div key = {index} style = {{width: '400px', height: '400px', margin: '2em 2em', float: 'left'}}>{item}</div>\r\n                            )\r\n                            }\r\n                        )\r\n                        }\r\n\r\n                        </Col>\r\n                    </Row>\r\n          \r\n    \r\n    // stores the html element of the game.\r\n    let gameMode = (this.state.gameMode === 'menu' ? \r\n                    <Container className = 'gamecontainer'>\r\n                        <h3>Choose A Mode:</h3>\r\n                        <button onClick={this.handleGameMode.bind(this, '2playergame')}>Human v. Human</button>\r\n                        <button onClick={this.handleGameMode.bind(this, 'aigame')}>Human v. AI</button>\r\n                    </Container> :\r\n                    <div className = 'gamecontainer'>\r\n                      \r\n                      <div className = 'gameboard' style={{display: 'inline-block'}}\r\n                      onTransitionEnd={this.state.gameMode === 'aigame' && this.state.activePlayer === white ? this.handleAI.bind(this, gameInfo) : null}\r\n                         >\r\n                        {this.createGameBoard(this.state.gameState)}   \r\n          \r\n                      </div>\r\n                     \r\n                      \r\n                        <h4>{this.state.activePlayer === black ? 'Player 1' : 'Player 2'}'s Turn</h4> \r\n                        <div>\r\n                          <h5>Score for Player 1:</h5>\r\n                          <p>{this.state.blackPoints}</p>\r\n                        </div>\r\n                        <div>\r\n                          <h5>Score for Player 2:</h5>\r\n                          <p>{this.state.whitePoints}</p>\r\n                        </div>\r\n \r\n                        {this.state.gameMode === 'gameover' ? \r\n                         <div style={{position: 'absolute', top: '215px', left: '180px', width: '200px', backgroundColor: 'rgba(200,200,200,0.9)', textAlign: 'center', padding: '15px', color: 'black'}}>\r\n                              <h5>Game Over <br /> {this.state.blackPoints === this.state.whitePoints ? \r\n                              'Tie Game' : (this.state.blackPoints > this.state.whitePoints ? 'Black Wins' : 'White Wins')} </h5> \r\n                        </div> : null }\r\n                      </div>\r\n                      )\r\n\r\n    //stores the html element of the settings\r\n    let settings = <Container>\r\n                    <h4>Settings</h4>\r\n                    <h6 style={{marginTop: '1em'}}>Choose your color:</h6>\r\n                    <Button variant={this.state.humanIsBlack ? 'dark' : 'light'} onClick = {this.toggleColor}>Toggle Color</Button>\r\n                    <h6 style={{marginTop: '1em'}}>Current Game Trace</h6>\r\n                    <Form>\r\n                      <Form.Check \r\n                        onClick={this.toggleProgramTrace}\r\n                        type=\"switch\"\r\n                        id=\"trace-switch\"\r\n                        label= {this.state.programTrace ? \"On\" : \"Off\"}\r\n                      />\r\n                    </Form>\r\n                    <h6 style={{marginTop: '1em'}}>Debug Mode</h6>\r\n                    <Form>\r\n                      <Form.Check \r\n                        onClick={this.toggleDebug}\r\n                        type=\"switch\"\r\n                        id=\"debug-switch\"\r\n                        label= {this.state.debugMode ? \"On\" : \"Off\"}\r\n                      />\r\n                    </Form>\r\n                    <h6 style={{marginTop: '1em'}}>Cheat</h6>\r\n                    <Button variant = \"primary\" onClick={this.handleAI.bind(this, gameInfo)}>Click for an AI play</Button>\r\n                    <h6 style={{marginTop: '1em'}}>Alpha Beta Pruning</h6>\r\n                    <Form>\r\n                      <Form.Check \r\n                        onClick={this.togglePruning}\r\n                        type=\"switch\"\r\n                        id=\"pruning-switch\"\r\n                        label= {this.state.pruning ? \"On\" : \"Off\"}\r\n                      />\r\n                    </Form>\r\n                 \r\n                  <h6 style={{marginTop: '1em'}}>Depth</h6>\r\n                  <Form>\r\n                    <Form.Check\r\n                        defaultChecked\r\n                        custom\r\n                        type=\"radio\"\r\n                        label=\"2\"\r\n                        name=\"formHorizontalRadios\"\r\n                        id=\"formHorizontalRadios1\"\r\n                        onClick = {this.handleDepth.bind(this, 3)}\r\n                      />\r\n                      <Form.Check\r\n                        custom\r\n                        type=\"radio\"\r\n                        label=\"4\"\r\n                        name=\"formHorizontalRadios\"\r\n                        id=\"formHorizontalRadios2\"\r\n                        onClick = {this.handleDepth.bind(this, 5)}\r\n                      />\r\n                      <Form.Check\r\n                        custom\r\n                        type=\"radio\"\r\n                        label=\"6\"\r\n                        name=\"formHorizontalRadios\"\r\n                        id=\"formHorizontalRadios3\"\r\n                        onClick = {this.handleDepth.bind(this, 7)}\r\n                      />\r\n                      <Form.Check\r\n                        custom\r\n                        type=\"radio\"\r\n                        label=\"8\"\r\n                        name=\"formHorizontalRadios\"\r\n                        id=\"formHorizontalRadios4\"\r\n                        onClick = {this.handleDepth.bind(this, 9)}\r\n                      />\r\n                  </Form>\r\n                  </Container>\r\n\r\n    // stores the html element of the debug mode\r\n    let debugMode2 = <div style={{margin: '50px'}} >\r\n                      <h4>Debug Mode</h4>\r\n                    \r\n\r\n                      {this.state.debugDepth !== undefined ? \r\n                        <div>\r\n                          <p>\r\n                          {this.state.debugDepth !== this.state.aiDepth ? <button onClick = {this.handleDebugDepth.bind(this, 1)}>Go Up One Level</button> : null}\r\n                          {this.state.debugDepth !== 0 ? <button onClick = {this.handleDebugDepth.bind(this, -1)}>Go Down One Level</button> : null}\r\n                        </p>\r\n                        <p>Level {this.state.debugDepth}</p> \r\n                        </div> : \r\n                        null\r\n                \r\n                      }\r\n                      \r\n                      <Row>\r\n                        <Col xs = {12}>\r\n                        {possibleMoves.map((item, index) => {                        \r\n                          if (item.depth === this.state.debugDepth){\r\n                            \r\n                          return(\r\n                            <div style = {{width: '400px', height: '400px', margin: '2em 2em', float: 'left'}}>{item.board}Depth: {item.depth}; Score: {item.score}</div>\r\n                            )\r\n                   \r\n                          }\r\n                          else{\r\n                            return(\r\n                              null\r\n                            )\r\n                          }\r\n                        \r\n\r\n                 \r\n                      }\r\n                        )\r\n                      }\r\n                       \r\n                        </Col>\r\n                      </Row>\r\n                     \r\n                      <Row style={{border: '1px solid black'}}>\r\n                      <Col xs = {12}>\r\n                      {this.state.pruning ? <h5>Prunes:</h5> : null}\r\n                      {prunes.map(item => {\r\n                        if (item.depth-1 === this.state.debugDepth){\r\n                          return(\r\n                            <div style = {{width: '400px', height: '400px', margin: '2em 2em', float: 'left'}}>{item.board}Depth: {item.depth-1}; </div>\r\n                          )\r\n                          \r\n                        }\r\n                        else{\r\n                          return(\r\n                            null\r\n                          )\r\n                        }\r\n                      }\r\n                      )}\r\n                      </Col>\r\n                      </Row>\r\n                      \r\n                    </div>\r\n\r\n  \r\n          \r\n    // returns the entire game to be displayed.\r\n    return(\r\n      <React.Fragment>\r\n      <Row>\r\n        <Col className = 'settings' xs  = {3}>{this.state.gameMode === '2playergame' || this.state.gameMode === 'aigame' ? settings : null}</Col>\r\n        <Col className = 'gameMode' xs = {4}>{gameMode}</Col>\r\n      </Row>\r\n        {this.state.programTrace ? <Row style = {{marginTop: '200px'}}><Col className = 'debug'>{allMoves}</Col></Row> : null}\r\n        {this.state.debugMode ? <Row style = {{marginTop: '200px'}}><Col className = 'debug'>{debugMode2}</Col></Row> : null}\r\n      </React.Fragment> \r\n    )\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}