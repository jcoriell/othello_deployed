{"version":3,"sources":["components/Tile.js","components/DebugTile.js","App.js","serviceWorker.js","index.js"],"names":["Tile","handleClick","bind","determineTileType","this","props","gameMode","tileValue","available","newGameState","handleGameState","rowIndex","colIndex","activePlayer","gameState","gameStateTranspose","updateMovesSoFar","updateState","black","humanIsBlack","tileStyle","Col","className","onClick","React","Component","DebugTile","white","possibleMoves","prunes","movesSoFar","App","state","inactivePlayer","blackPoints","whitePoints","availablePoints","debugBoards","debugMode","pruning","aiDepth","moves3","moves2","moves1","programTrace","setPlayer","checkTileOnRight","checkTileOnLeft","checkTileAbove","checkTileBelow","checkNorthEast","checkNorthWest","checkSouthEast","checkSouthWest","updateScore","handleGameMode","handleAI","checkForWin","bestPlay","minimax","createGameBoard","toggleColor","createDebugBoard","toggleDebug","alphabetaprune","togglePruning","handleDepth","handleDebugDepth","toggleProgramTrace","gameInfo","map","i","Row","key","j","push","console","log","coordinates","row","col","mode","setState","blackScore","whiteScore","availableSpots","length","winning","depth","debugDepth","result","player","alpha","beta","newGameStateTranspose","availables","nodeScore","heuristic","board","score","bestMove","moves","move","value","breadth","tiles","k","pruneBoard","minimaxResult","bestScore","tempGameState","tilesOnRightFromMeToRight","tileOnRightIsActivePlayer","firstInactivePlayerIndex","indexOf","firstBlankIndex","tilesOnLeftFromMeToLeft","tileOnLeftIsActivePlayer","tempGameStateTranspose","tilesAboveFromMeToTop","slice","reverse","tileAboveIsActivePlayer","tilesBelowFromMeToBottom","tileBelowIsActivePlayer","tilesFromMeToNorthEast","tileNorthEastIsActivePlayer","tilesFromMeToNorthWest","tileNorthWestIsActivePlayer","tilesFromMeToSouthEast","tileSouthEastIsActivePlayer","tilesFromMeToSouthWest","tileSouthWestIsActivePlayer","updatedGameState","updatedGameStateTranspose","downExistance","i_d","j_d","blankBelow","availableBelow","blankBeforeCurrentPlayer_d","availableBeforeCurrentPlayer_d","k_d","upExistance","i_u","j_u","blankAbove","availableAbove","blankBeforeCurrentPlayer_u","availableBeforeCurrentPlayer_u","k_u","leftExistance","i_l","j_l","blankLeft","availableLeft","blankBeforeCurrentPlayer_l","availableBeforeCurrentPlayer_l","k_l","rightExistance","i_r","j_r","blankRight","availableRight","blankBeforeCurrentPlayer_r","availableBeforeCurrentPlayer_r","k_r","nwDiagonalExistance","i_nwd","j_nwd","blankNW","availableNW","blankBeforeCurrentPlayer_nw","availableBeforeCurrentPlayer_nw","k_nwd","neDiagonalExistance","i_ned","j_ned","blankNE","availableNE","blankBeforeCurrentPlayer_ne","availableBeforeCurrentPlayer_ne","k_ned","seDiagonalExistance","i_sed","j_sed","blankSE","availableSE","blankBeforeCurrentPlayer_se","availableBeforeCurrentPlayer_se","k_sed","swDiagonalExistance","i_swd","j_swd","blankSW","availableSW","blankBeforeCurrentPlayer_sw","availableBeforeCurrentPlayer_sw","k_swd","index_i","index_j","scoreOfState","newScore","change","allMoves","style","margin","xs","item","width","height","float","Container","display","onTransitionEnd","position","top","left","backgroundColor","textAlign","padding","color","settings","marginTop","Button","variant","Form","Check","type","id","label","defaultChecked","custom","name","debugMode2","undefined","index","border","Fragment","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.fcc1477c.chunk.js","sourcesContent":["import React from 'react';\r\nimport '../App.css';\r\nimport { Col } from 'react-bootstrap'\r\n\r\nclass Tile extends React.Component{\r\n    constructor(){\r\n        super();\r\n        this.handleClick = this.handleClick.bind(this);\r\n        this.determineTileType = this.determineTileType.bind(this);\r\n    }\r\n\r\n    handleClick(){\r\n        if (this.props.gameMode === '2playergame' && this.props.tileValue === this.props.available ){\r\n           let newGameState = this.props.handleGameState(this.props.rowIndex, this.props.colIndex, this.props.activePlayer, this.props.gameState, this.props.gameStateTranspose);\r\n           this.props.updateMovesSoFar(newGameState);\r\n           this.props.updateState(newGameState.gameState, newGameState.gameStateTranspose, newGameState.activePlayer)\r\n        }\r\n        if (this.props.gameMode === 'aigame' && this.props.tileValue === this.props.available && this.props.activePlayer === this.props.black){\r\n           let newGameState = this.props.handleGameState(this.props.rowIndex, this.props.colIndex, this.props.activePlayer, this.props.gameState, this.props.gameStateTranspose);\r\n           this.props.updateMovesSoFar(newGameState);\r\n           this.props.updateState(newGameState.gameState, newGameState.gameStateTranspose, newGameState.activePlayer)\r\n        }\r\n        \r\n    }\r\n\r\n    determineTileType(){\r\n        let result;\r\n\r\n        if (this.props.tileValue === 1){\r\n            if (this.props.humanIsBlack){\r\n                result = 'player1'\r\n            }\r\n            else{\r\n                result = 'player2'\r\n            }\r\n        }\r\n        else if (this.props.tileValue === 2){\r\n            if (this.props.humanIsBlack){\r\n                result = 'player2'\r\n            }\r\n            else{\r\n                result = 'player1'\r\n            }\r\n        }\r\n        else if (this.props.tileValue=== this.props.available){\r\n            result = 'adjacentTile'\r\n        }\r\n        else {\r\n            result = 'empty'\r\n        }\r\n        return result;\r\n    }\r\n\r\n    render(){\r\n        let tileStyle = this.determineTileType();\r\n\r\n        return(\r\n            <Col className = 'mycol' onClick={this.handleClick}><div className = {tileStyle}></div></Col>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Tile;","import React from 'react';\r\nimport '../App.css';\r\nimport { Col } from 'react-bootstrap'\r\n\r\nclass DebugTile extends React.Component{\r\n    constructor(){\r\n        super();\r\n        this.determineTileType = this.determineTileType.bind(this)\r\n    }\r\n\r\n    determineTileType(){\r\n        let result;\r\n\r\n        if (this.props.tileValue === 1){\r\n            if (this.props.humanIsBlack){\r\n                result = 'player1'\r\n            }\r\n            else{\r\n                result = 'player2'\r\n            }\r\n        }\r\n        else if (this.props.tileValue === 2){\r\n            if (this.props.humanIsBlack){\r\n                result = 'player2'\r\n            }\r\n            else{\r\n                result = 'player1'\r\n            }\r\n        }\r\n        else if (this.props.tileValue=== this.props.available){\r\n            result = 'adjacentTile'\r\n        }\r\n        else {\r\n            result = 'empty'\r\n        }\r\n        return result;\r\n    }\r\n\r\n    render(){\r\n        let tileStyle = this.determineTileType();\r\n\r\n        return(\r\n            <Col className = 'mycol'><div className = {tileStyle}></div></Col>\r\n        )\r\n    }\r\n\r\n}\r\n\r\n\r\nexport default DebugTile;\r\n","/*\r\nJoshua Coriell\r\nTuesday, Novemeber 12\r\nCWID: 101-75-228\r\nAssignment #3 - Othello\r\n\r\nDescription:\r\nThis program implements Othello. You can play with two humans, or a human can play against an AI.\r\n*/\r\n\r\n\r\n\r\nimport React from 'react';\r\nimport './App.css';\r\nimport { Row, Container, Col, Form, Button } from 'react-bootstrap';\r\nimport Tile from './components/Tile';\r\nimport DebugTile from './components/DebugTile'\r\n\r\nvar black = 1;\r\nvar white = 2;\r\nconst available = 8;\r\nconst blank = 0;\r\nvar possibleMoves = [];\r\nvar prunes = [];\r\nvar movesSoFar = [];\r\n\r\nclass App extends React.Component{\r\n  constructor(){\r\n    super()\r\n    this.state = {\r\n      // 8 means valid move for current player, 1 is black, 2 white\r\n      gameState : [[0,0,0,0,0,0,0,0],\r\n                   [0,0,0,0,0,0,0,0],\r\n                   [0,0,0,available,0,0,0,0],\r\n                   [0,0,available,white,black,0,0,0],\r\n                   [0,0,0,black,white,available,0,0],\r\n                   [0,0,0,0,available,0,0,0],\r\n                   [0,0,0,0,0,0,0,0],\r\n                   [0,0,0,0,0,0,0,0],],\r\n      gameStateTranspose : [[0,0,0,0,0,0,0,0],\r\n                            [0,0,0,0,0,0,0,0],\r\n                            [0,0,0,available,0,0,0,0],\r\n                            [0,0,available,white,black,0,0,0],\r\n                            [0,0,0,black,white,available,0,0],\r\n                            [0,0,0,0,available,0,0,0],\r\n                            [0,0,0,0,0,0,0,0],\r\n                            [0,0,0,0,0,0,0,0],],\r\n      activePlayer : black,\r\n      inactivePlayer : white,\r\n      blackPoints: 2,\r\n      whitePoints: 2,\r\n      availablePoints: 4,\r\n      gameMode: 'menu',\r\n      humanIsBlack: true,\r\n      debugBoards: [],\r\n      debugMode: false,\r\n      pruning: false,\r\n      aiDepth: 3,\r\n      moves3: [],\r\n      moves2: [],\r\n      moves1: [],\r\n      programTrace: false,\r\n    }\r\n    this.setPlayer = this.setPlayer.bind(this);\r\n    this.handleGameState = this.handleGameState.bind(this);\r\n    this.checkTileOnRight = this.checkTileOnRight.bind(this);\r\n    this.checkTileOnLeft = this.checkTileOnLeft.bind(this);\r\n    this.checkTileAbove = this.checkTileAbove.bind(this);\r\n    this.checkTileBelow = this.checkTileBelow.bind(this);\r\n    this.checkNorthEast = this.checkNorthEast.bind(this);\r\n    this.checkNorthWest = this.checkNorthWest.bind(this);\r\n    this.checkSouthEast = this.checkSouthEast.bind(this);\r\n    this.checkSouthWest = this.checkSouthWest.bind(this);\r\n    this.updateScore = this.updateScore.bind(this);\r\n    this.handleGameMode = this.handleGameMode.bind(this);\r\n    this.handleAI = this.handleAI.bind(this);\r\n    this.checkForWin = this.checkForWin.bind(this);\r\n    this.bestPlay = this.bestPlay.bind(this);\r\n    this.minimax = this.minimax.bind(this);\r\n    this.updateState = this.updateState.bind(this);\r\n    this.createGameBoard = this.createGameBoard.bind(this);\r\n    this.toggleColor = this.toggleColor.bind(this);\r\n    this.createDebugBoard = this.createDebugBoard.bind(this);\r\n    this.toggleDebug = this.toggleDebug.bind(this)\r\n    this.alphabetaprune = this.alphabetaprune.bind(this);\r\n    this.togglePruning = this.togglePruning.bind(this);\r\n    this.handleDepth = this.handleDepth.bind(this);\r\n    this.handleDebugDepth = this.handleDebugDepth.bind(this);\r\n    this.updateMovesSoFar = this.updateMovesSoFar.bind(this);\r\n    this.toggleProgramTrace = this.toggleProgramTrace.bind(this);\r\n  }\r\n\r\n\r\n  createDebugBoard(gameInfo){\r\n  \r\n    let result = gameInfo.gameState.map((i, rowIndex) => {\r\n    \r\n      return(\r\n          <Row className = 'myrow' key = {rowIndex}>\r\n            {i.map((j, colIndex) => {\r\n              return(\r\n                <DebugTile \r\n                  key = {colIndex}\r\n                  tileValue = {j} \r\n                  humanIsBlack = {this.state.humanIsBlack}\r\n                  available = {available}\r\n                  />\r\n              )\r\n              })\r\n            }\r\n          </Row>\r\n        )\r\n      })\r\n\r\n      return result\r\n \r\n  }\r\n\r\n  updateMovesSoFar(gameInfo){\r\n    movesSoFar.push(this.createDebugBoard(gameInfo))\r\n  }\r\n\r\n  \r\n\r\n\r\n\r\n  handleAI(gameInfo){\r\n    console.log('ai has been handled')\r\n    let coordinates = this.bestPlay(gameInfo)\r\n    let newGameState = this.handleGameState(coordinates.row, coordinates.col, gameInfo.activePlayer, gameInfo.gameState, gameInfo.gameStateTranspose)\r\n    this.updateMovesSoFar(newGameState);\r\n    this.updateState(newGameState.gameState, newGameState.gameStateTranspose, newGameState.activePlayer)\r\n  }\r\n\r\n  handleGameMode(mode){\r\n    this.setState({gameMode: mode})\r\n  }\r\n\r\n  updateScore(gameState){\r\n    let blackScore = 0;\r\n    let whiteScore = 0;\r\n    let availableSpots = 0;\r\n    for (let i = 0; i < gameState.length; i++){\r\n      for (let j = 0; j < gameState[i].length; j++){\r\n        if (gameState[i][j] === black){blackScore++;}\r\n        if (gameState[i][j] === white){whiteScore++;}\r\n        if (gameState[i][j] === available){availableSpots++}\r\n      }\r\n    }\r\n\r\n\r\n    let result = {blackPoints: blackScore, whitePoints: whiteScore, availablePoints: availableSpots}\r\n    return result\r\n  }\r\n\r\n  checkForWin(blackScore, whiteScore, availableSpots){\r\n      let winning = null;\r\n        if (blackScore > whiteScore){\r\n          winning = 'Black';\r\n        }\r\n        if (whiteScore > blackScore){\r\n          winning = 'White';\r\n        }\r\n        if (blackScore === whiteScore){\r\n          winning = 'tie';\r\n        }\r\n        if (blackScore + whiteScore === 64 || availableSpots === 0){\r\n          this.handleGameMode('gameover')\r\n        }\r\n      return winning;\r\n  }\r\n\r\n  bestPlay(gameInfo){\r\n    /*\r\n    let inputRow;\r\n    let inputCol;\r\n    loop:\r\n    for (let i = 0; i < gameState.length; i++){\r\n      for (let j = 0; j < gameState[i].length; j++){\r\n        if(gameState[i][j] === available){\r\n          inputRow = i;\r\n          inputCol = j;\r\n          console.log('Best Play was at (Row = ' + inputRow + ', Col = ' + inputCol +')')\r\n          break loop;\r\n        }\r\n      }\r\n    }\r\n    let coordinates = {row: inputRow, col: inputCol};\r\n    */\r\n   possibleMoves = [];\r\n   prunes = []\r\n   let coordinates;\r\n   let depth = this.state.aiDepth;\r\n   this.setState({debugDepth: this.state.aiDepth})\r\n   if (this.state.pruning){\r\n    let alpha = -10000\r\n    let beta = 10000\r\n    \r\n    let result = this.alphabetaprune(gameInfo, gameInfo.activePlayer, depth, alpha, beta)\r\n    console.log(result)\r\n    coordinates = {row: result.row, col: result.col}\r\n   }\r\n\r\n   else { \r\n    let result = this.minimax(gameInfo, gameInfo.activePlayer, depth)\r\n    console.log(result)\r\n    coordinates = {row: result.row, col: result.col}\r\n   }\r\n\r\n    return coordinates;\r\n    \r\n  }\r\n\r\n  alphabetaprune(gameInfo, player, depth, alpha, beta) {\r\n    let newGameState = gameInfo.gameState;\r\n    let newGameStateTranspose = gameInfo.gameStateTranspose;\r\n    // find the row and column of available spots to play in the incoming gamestate\r\n    let availables = [];\r\n    \r\n\r\n    for (let i = 0; i < newGameState.length; i++){\r\n      for (let j = 0; j < newGameState[i].length; j++){\r\n        if (newGameState[i][j] === available){\r\n          availables.push({row: i, col: j})\r\n        }\r\n      }\r\n    }\r\n\r\n    let nodeScore = this.updateScore(newGameState)\r\n    let heuristic = 100 * (nodeScore.whitePoints - nodeScore.blackPoints) / (nodeScore.whitePoints + nodeScore.blackPoints)\r\n\r\n    if (availables.length === 0 && nodeScore.whitePoints > nodeScore.blackPoints){\r\n      heuristic = 100\r\n    }\r\n    else if (availables.length === 0 && nodeScore.blackPoints > nodeScore.whitePoints){\r\n      heuristic = -100\r\n    }\r\n    else if (availables.length === 0){\r\n      heuristic = 0\r\n    }\r\n\r\n    if (this.state.debugMode){\r\n      possibleMoves.push({board: this.createDebugBoard(gameInfo), depth: depth, score: heuristic})\r\n    }\r\n\r\n    // check if you are at max depth.\r\n    if (depth === 0){\r\n      // if you are at max depth return the score of that node.\r\n     /* if (player === black){\r\n        let heuristic = 100 * (nodeScore.blackPoints - nodeScore.whitePoints) / (nodeScore.blackPoints + nodeScore.whitePoints)\r\n        return {score: heuristic}\r\n      }\r\n      if (player === white){*/\r\n        //let heuristic = 100 * (nodeScore.whitePoints - nodeScore.blackPoints) / (nodeScore.whitePoints + nodeScore.blackPoints)\r\n        return {score: heuristic}\r\n      //}\r\n          \r\n    }\r\n    else if (availables.length === 0){\r\n      return {score: heuristic}\r\n    }\r\n    \r\n    // create something that can store the scores for each move that is made (an array called moveScores = []). these will be evaluated later.\r\n    let moves = [];\r\n    // start a loop that runs through the available spots to play.\r\n    for (let i = 0; i < availables.length; i++){\r\n        // at the beginning of the loop, create an object that stores the row of the move, the col of the move, and the score that results from that move.\r\n        let move = {};\r\n        // set the row of the move object to row of the ith item in the array of available spots to play\r\n        // set the col of the move object to the col of the ith item in the array of available spots ot play\r\n        ///something might not be right here?????\r\n        move.value = newGameState[availables[i].row][availables[i].col]\r\n        move.row = availables[i].row;\r\n        move.col = availables[i].col;\r\n        move.breadth = i;\r\n        \r\n        \r\n        let tiles = [];\r\n        for (let j = 0; j < newGameState.length; j++){\r\n          for (let k = 0; k < newGameState[j].length; k++){\r\n            tiles.push({row: j, col: k, value: newGameState[j][k]})\r\n          }\r\n        }\r\n \r\n      \r\n       \r\n        //simiulate a play by the current player\r\n        let result = this.handleGameState(availables[i].row, availables[i].col, player, newGameState, newGameStateTranspose)\r\n        if (this.state.debugMode){\r\n          var pruneBoard = this.createDebugBoard(result)\r\n        }\r\n\r\n        // if the player is the (ai) white player, \r\n        if (player === white){\r\n          //then store the result of calling minimax on the newGameState with the black player and one more level of depth\r\n          let minimaxResult = this.alphabetaprune(result, black, depth - 1, alpha, beta)\r\n          //also set the score of the move object to the score of the result of calling that minimax algorithm\r\n          move.score = minimaxResult.score\r\n\r\n          // set the board back to how it was if the play never happened. \r\n          for (let j = 0; j < tiles.length; j++){\r\n            newGameState[tiles[j].row][tiles[j].col] = tiles[j].value\r\n            newGameStateTranspose[tiles[j].col][tiles[j].row] = tiles[j].value\r\n          }\r\n          moves.push(move)\r\n          /// compare alpha to move.score and set alpha to whichever is larger\r\n          if (alpha < move.score){\r\n            alpha = move.score\r\n          }\r\n          /// if beta is less than alpha at this point, break out of the parent for loop\r\n          if (beta <= alpha){\r\n            if(this.state.debugMode){\r\n              prunes.push({depth: depth, breadth: move.breadth, board: pruneBoard})\r\n            }\r\n            break\r\n          }\r\n        }\r\n        // else, when it is not the AI's turn...\r\n        else {\r\n          //then store the result of calling minimax on the newGameState with the white player and one more level of depth\r\n          let minimaxResult = this.alphabetaprune(result, white, depth - 1, alpha, beta)\r\n          //also set the score of the move object to the score of the result of calling that minimax algorithm\r\n          move.score = minimaxResult.score\r\n\r\n          // set the board back to how it was if the play never happened. \r\n          for (let j = 0; j < tiles.length; j++){\r\n            newGameState[tiles[j].row][tiles[j].col] = tiles[j].value\r\n            newGameStateTranspose[tiles[j].col][tiles[j].row] = tiles[j].value\r\n          }\r\n\r\n          // moves.push(move) will add the score to the moves array for this iteration.\r\n          moves.push(move)\r\n\r\n          // compare beta to move.score and set beta to whichever is smaller.\r\n          if (beta > move.score){\r\n            beta = move.score\r\n          }\r\n          // if beta is less than alpha at this point, break out of the parent for loop\r\n          if (beta <= alpha){\r\n            if (this.state.debugMode){\r\n              prunes.push({depth: depth, breadth: move.breadth, board: pruneBoard})\r\n            }\r\n            break\r\n          }\r\n        }\r\n        // set the board back to how it was if the play never happened.    \r\n\r\n      \r\n        // moves.push(move) will add the score to the moves array for this iteration.\r\n        //moves.push(move)\r\n    }\r\n    // determine the best move to make.\r\n    let bestMove;\r\n    // if the player is white...\r\n    if (player === white){\r\n      let bestScore = -10000;\r\n      // loop through the moves array (all the scores). \r\n      for (let i = 0; i < moves.length; i++){\r\n        // if the score of the ith item is larger than the bestScore variable:\r\n        if (moves[i].score > bestScore){\r\n          // set bestScore to the score of that move.\r\n          bestScore = moves[i].score\r\n          // set bestMove = index of moves array\r\n          bestMove = i;\r\n        }\r\n      }\r\n    }\r\n    // if the player is black, chose the lowest score.\r\n    else {\r\n      // create a variable called bestScore and set it to a really large number (10000)\r\n      let bestScore = 10000;\r\n      for (let i = 0; i < moves.length; i++){\r\n        // if the score of the ith item is less than the bestScore variable:\r\n        if (moves[i].score < bestScore){\r\n          // set bestScore to the score of that move.\r\n          bestScore = moves[i].score\r\n          // set bestMove = index of moves array\r\n          bestMove = i;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return moves[bestMove];\r\n  }\r\n  \r\n\r\n\r\n\r\n\r\n\r\n  minimax(gameInfo, player, depth) {\r\n    let newGameState = gameInfo.gameState;\r\n    let newGameStateTranspose = gameInfo.gameStateTranspose;\r\n    // find the row and column of available spots to play in the incoming gamestate\r\n    let availables = [];\r\n    \r\n    for (let i = 0; i < newGameState.length; i++){\r\n      for (let j = 0; j < newGameState[i].length; j++){\r\n        if (newGameState[i][j] === available){\r\n          availables.push({row: i, col: j})\r\n        }\r\n      }\r\n    }\r\n\r\n    let nodeScore = this.updateScore(newGameState)\r\n    let heuristic = 100 * (nodeScore.whitePoints - nodeScore.blackPoints) / (nodeScore.whitePoints + nodeScore.blackPoints)\r\n    if (availables.length === 0 && nodeScore.whitePoints > nodeScore.blackPoints){\r\n      heuristic = 100\r\n    }\r\n    else if (availables.length === 0 && nodeScore.blackPoints > nodeScore.whitePoints){\r\n      heuristic = -100\r\n    }\r\n    else if (availables.length === 0){\r\n      heuristic = 0\r\n    }\r\n\r\n    // check if you are at max depth.\r\n    if(this.state.debugMode){\r\n      possibleMoves.push({board: this.createDebugBoard(gameInfo), depth: depth, score: heuristic})\r\n    }\r\n    if (depth === 0){\r\n      // if you are at max depth return the score of that node.\r\n     /* if (player === black){\r\n        let heuristic = 100 * (nodeScore.blackPoints - nodeScore.whitePoints) / (nodeScore.blackPoints + nodeScore.whitePoints)\r\n        return {score: heuristic}\r\n      }\r\n      if (player === white){*/\r\n        return {score: heuristic}\r\n      //}\r\n          \r\n    }\r\n    else if (availables.length === 0){\r\n\r\n        return {score: heuristic}\r\n    \r\n    }\r\n    \r\n    \r\n    // create something that can store the scores for each move that is made (an array called moveScores = []). these will be evaluated later.\r\n    let moves = [];\r\n    // start a loop that runs through the available spots to play.\r\n    for (let i = 0; i < availables.length; i++){\r\n        // at the beginning of the loop, create an object that stores the row of the move, the col of the move, and the score that results from that move.\r\n        let move = {};\r\n        // set the row of the move object to row of the ith item in the array of available spots to play\r\n        // set the col of the move object to the col of the ith item in the array of available spots ot play\r\n        ///something might not be right here?????\r\n        move.value = newGameState[availables[i].row][availables[i].col]\r\n        move.row = availables[i].row;\r\n        move.col = availables[i].col;\r\n        \r\n        let tiles = [];\r\n        for (let j = 0; j < newGameState.length; j++){\r\n          for (let k = 0; k < newGameState[j].length; k++){\r\n            tiles.push({row: j, col: k, value: newGameState[j][k]})\r\n          }\r\n        }\r\n \r\n      \r\n       \r\n        //simiulate a play by the current player\r\n        let result = this.handleGameState(availables[i].row, availables[i].col, player, newGameState, newGameStateTranspose)\r\n        //move.board = this.createDebugBoard(result)\r\n        //move.breadth = i\r\n\r\n        \r\n\r\n        // if the player is the (ai) white player, \r\n        if (player === white){\r\n          //then store the result of calling minimax on the newGameState with the black player and one more level of depth\r\n          let minimaxResult = this.minimax(result, black, depth - 1)\r\n          //also set the score of the move object to the score of the result of calling that minimax algorithm\r\n          move.score = minimaxResult.score\r\n\r\n          // set the board back to how it was if the play never happened. \r\n          for (let j = 0; j < tiles.length; j++){\r\n            newGameState[tiles[j].row][tiles[j].col] = tiles[j].value\r\n            newGameStateTranspose[tiles[j].col][tiles[j].row] = tiles[j].value\r\n          }\r\n          \r\n          moves.push(move)\r\n          /// compare alpha to move.score and set alpha to whichever is larger\r\n\r\n        }\r\n        // else, when it is not the AI's turn...\r\n        else {\r\n          //then store the result of calling minimax on the newGameState with the white player and one more level of depth\r\n          let minimaxResult = this.minimax(result, white, depth - 1)\r\n          //also set the score of the move object to the score of the result of calling that minimax algorithm\r\n          move.score = minimaxResult.score\r\n\r\n          // set the board back to how it was if the play never happened. \r\n          for (let j = 0; j < tiles.length; j++){\r\n            newGameState[tiles[j].row][tiles[j].col] = tiles[j].value\r\n            newGameStateTranspose[tiles[j].col][tiles[j].row] = tiles[j].value\r\n          }\r\n\r\n          // moves.push(move) will add the score to the moves array for this iteration.\r\n          \r\n          moves.push(move)\r\n\r\n          // compare beta to move.score and set beta to whichever is smaller.\r\n        }\r\n        // set the board back to how it was if the play never happened.    \r\n\r\n      \r\n        // moves.push(move) will add the score to the moves array for this iteration.\r\n        //moves.push(move)\r\n    }\r\n    // determine the best move to make.\r\n    let bestMove;\r\n    // if the player is white...\r\n    if (player === white){\r\n      let bestScore = -10000;\r\n      // loop through the moves array (all the scores). \r\n      for (let i = 0; i < moves.length; i++){\r\n        // if the score of the ith item is larger than the bestScore variable:\r\n        if (moves[i].score > bestScore){\r\n          // set bestScore to the score of that move.\r\n          bestScore = moves[i].score\r\n          // set bestMove = index of moves array\r\n          bestMove = i;\r\n        }\r\n      }\r\n    }\r\n    // if the player is black, chose the lowest score.\r\n    else {\r\n      // create a variable called bestScore and set it to a really large number (10000)\r\n      let bestScore = 10000;\r\n      for (let i = 0; i < moves.length; i++){\r\n        // if the score of the ith item is less than the bestScore variable:\r\n        if (moves[i].score < bestScore){\r\n          // set bestScore to the score of that move.\r\n          bestScore = moves[i].score\r\n          // set bestMove = index of moves array\r\n          bestMove = i;\r\n        }\r\n      }\r\n    }\r\n    /*\r\n  \r\n    let key = 'moves' + depth\r\n    \r\n    if (key === 'moves3'){\r\n      this.setState({[key]: [...this.state.moves3, moves]})\r\n    }\r\n    if (key === 'moves2'){\r\n      this.setState({[key]: [...this.state.moves2, moves]})\r\n    }\r\n    if (key === 'moves1'){\r\n      this.setState({[key]: [...this.state.moves1, moves]})\r\n    }*/\r\n    return moves[bestMove];\r\n    \r\n  }\r\n  \r\n\r\n  checkTileOnRight(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    // if you're on the edge, don't check the next tile.\r\n    if (colIndex === 7){return false}\r\n    // if you're not on the edge, see if the tile on the right is the same color as the person who just played and if the upcoming player has a piece in this row, return true.\r\n    else {\r\n      let tilesOnRightFromMeToRight = [];\r\n      let i = rowIndex;\r\n      let j = colIndex + 1;\r\n      while (j <= 7){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesOnRightFromMeToRight.push(result);\r\n        j++;\r\n      } \r\n      let tileOnRightIsActivePlayer = (tilesOnRightFromMeToRight[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesOnRightFromMeToRight.indexOf(inactivePlayer)\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let firstBlankIndex = tilesOnRightFromMeToRight.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      let inactivePlayerExistsInTilesOnRight = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      if (tileOnRightIsActivePlayer && inactivePlayerExistsInTilesOnRight && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n\r\n  }\r\n}\r\n\r\n  checkTileOnLeft(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    // if you're on the edge, don't check the previous tile.\r\n    if (colIndex === 0){return false}\r\n    else{\r\n      let tilesOnLeftFromMeToLeft = [];\r\n      let i = rowIndex;\r\n      let j = colIndex - 1;\r\n      while (j >= 0){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesOnLeftFromMeToLeft.push(result);\r\n        j--;\r\n      } \r\n      let tileOnLeftIsActivePlayer = (tilesOnLeftFromMeToLeft[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesOnLeftFromMeToLeft.indexOf(inactivePlayer)\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let firstBlankIndex = tilesOnLeftFromMeToLeft.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      let inactivePlayerExistsInTilesOnLeft = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      if (tileOnLeftIsActivePlayer && inactivePlayerExistsInTilesOnLeft && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n\r\n    }\r\n \r\n  \r\n  }\r\n\r\n  checkTileAbove(rowIndex, colIndex, activePlayer, tempGameStateTranspose){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    // if you're on the edge, don't check above.\r\n    if (rowIndex === 0){return false}\r\n    else{\r\n      let tilesAboveFromMeToTop = tempGameStateTranspose[colIndex].slice(0, rowIndex).reverse()  //creates an array of the tile on the right of the current one.\r\n      let tileAboveIsActivePlayer = (tilesAboveFromMeToTop[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesAboveFromMeToTop.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesAboveFromMeToTop.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInTilesAbove = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileAboveIsActivePlayer && inactivePlayerExistsInTilesAbove && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n\r\n\r\n    }\r\n  }\r\n\r\n  checkTileBelow(rowIndex, colIndex, activePlayer, tempGameStateTranspose){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    // if you're on the edge, don't check above.\r\n    if (rowIndex === 7){return false}\r\n    else{\r\n      let tilesBelowFromMeToBottom = tempGameStateTranspose[colIndex].slice(rowIndex + 1)\r\n      let tileBelowIsActivePlayer = (tilesBelowFromMeToBottom[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesBelowFromMeToBottom.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesBelowFromMeToBottom.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInTilesBelow = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileBelowIsActivePlayer && inactivePlayerExistsInTilesBelow && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n      \r\n    }\r\n  }\r\n\r\n\r\n  checkNorthEast(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    if (rowIndex ===  0 || colIndex === 7){return false}\r\n    else{\r\n      let tilesFromMeToNorthEast = [];\r\n      let i = rowIndex - 1;\r\n      let j = colIndex + 1;\r\n      while (i >= 0 && j <= 7){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesFromMeToNorthEast.push(result);\r\n        i--;\r\n        j++;\r\n      }\r\n      let tileNorthEastIsActivePlayer = (tilesFromMeToNorthEast[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesFromMeToNorthEast.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesFromMeToNorthEast.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInNorthEastTiles = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileNorthEastIsActivePlayer && inactivePlayerExistsInNorthEastTiles && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n    }\r\n\r\n  }\r\n\r\n\r\n  checkNorthWest(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    if (rowIndex ===  0 || colIndex === 0){return false}\r\n    else{\r\n      let tilesFromMeToNorthWest = [];\r\n      let i = rowIndex - 1;\r\n      let j = colIndex - 1;\r\n      while (i >= 0 && j >= 0){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesFromMeToNorthWest.push(result);\r\n        i--;\r\n        j--;\r\n      }\r\n      let tileNorthWestIsActivePlayer = (tilesFromMeToNorthWest[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesFromMeToNorthWest.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesFromMeToNorthWest.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInNorthWestTiles = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileNorthWestIsActivePlayer && inactivePlayerExistsInNorthWestTiles && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n    }\r\n\r\n  }\r\n\r\n  checkSouthEast(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    if (rowIndex ===  7 || colIndex === 7){return false}\r\n    else{\r\n      let tilesFromMeToSouthEast = [];\r\n      let i = rowIndex + 1;\r\n      let j = colIndex + 1;\r\n      while (i <= 7 && j <= 7){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesFromMeToSouthEast.push(result);\r\n        i++;\r\n        j++;\r\n      }\r\n      let tileSouthEastIsActivePlayer = (tilesFromMeToSouthEast[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesFromMeToSouthEast.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesFromMeToSouthEast.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInSouthEastTiles = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileSouthEastIsActivePlayer && inactivePlayerExistsInSouthEastTiles && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n    }\r\n\r\n  }\r\n\r\n  checkSouthWest(rowIndex, colIndex, activePlayer, tempGameState){\r\n    let inactivePlayer = (activePlayer === black ? white : black)\r\n    if (rowIndex ===  7 || colIndex === 0){return false}\r\n    else{\r\n      let tilesFromMeToSouthWest = [];\r\n      let i = rowIndex + 1;\r\n      let j = colIndex - 1;\r\n      while (i <= 7 && j >= 0){\r\n        let result;\r\n        if (tempGameState[i][j] === available){result = blank}\r\n        else{result = tempGameState[i][j]}\r\n        tilesFromMeToSouthWest.push(result);\r\n        i++;\r\n        j--;\r\n      }\r\n      let tileSouthWestIsActivePlayer = (tilesFromMeToSouthWest[0] === activePlayer ? true : false)\r\n      let firstInactivePlayerIndex = tilesFromMeToSouthWest.indexOf(inactivePlayer)\r\n      let firstBlankIndex = tilesFromMeToSouthWest.indexOf(blank)\r\n      if (firstBlankIndex === -1 ){firstBlankIndex = 20}\r\n      if (firstInactivePlayerIndex === -1){return false}\r\n      let inactivePlayerExistsInSouthWestTiles = (firstInactivePlayerIndex !== -1 ? true : false)\r\n      let inactivePlayerComesBeforeBlank = (firstInactivePlayerIndex < firstBlankIndex ? true : false)\r\n      if (tileSouthWestIsActivePlayer && inactivePlayerExistsInSouthWestTiles && inactivePlayerComesBeforeBlank){\r\n        return true\r\n      }\r\n      else{return false}\r\n    }\r\n \r\n  }\r\n\r\n\r\n  setPlayer(activePlayer){\r\n    if(activePlayer === black){\r\n      this.setState({activePlayer: white, inactivePlayer: black})\r\n    }\r\n    else if (activePlayer === white){\r\n      this.setState({activePlayer: black, inactivePlayer: white})\r\n    } \r\n  }\r\n\r\n\r\n  //this function updates the game state by assigning the player that just made a move to the appropriate square.\r\n  handleGameState(rowIndex, colIndex, activePlayer, gameState, gameStateTranspose){\r\n     //Initialize Updated Game State and it's transpose\r\n     let updatedGameState = gameState;\r\n     let updatedGameStateTranspose = gameStateTranspose;\r\n     let inactivePlayer = (activePlayer === black ? white : black)\r\n\r\n    // color downward\r\n    let downExistance = [];\r\n    let i_d = rowIndex + 1;\r\n    let j_d = colIndex;\r\n    while (i_d <= 7){\r\n      downExistance.push(updatedGameState[i_d][j_d])\r\n      i_d++;\r\n    }\r\n   \r\n    let blankBelow = downExistance.indexOf(blank) !== -1 ? true : false\r\n    let availableBelow = downExistance.indexOf(available) !== -1 ? true : false\r\n    let blankBeforeCurrentPlayer_d = downExistance.indexOf(blank) < downExistance.indexOf(activePlayer) ? true : false\r\n    let availableBeforeCurrentPlayer_d = downExistance.indexOf(available) < downExistance.indexOf(activePlayer) ? true : false\r\n    if (blankBelow && blankBeforeCurrentPlayer_d){\r\n      downExistance = [];\r\n    }\r\n    if ( availableBelow && availableBeforeCurrentPlayer_d ){\r\n      downExistance = [];\r\n    }\r\n\r\n    if (downExistance.indexOf(activePlayer) !== -1){\r\n     let i_d = rowIndex + 1;\r\n     let j_d = colIndex;\r\n     let k_d = 0;\r\n     while (i_d <= 7 && downExistance[k_d] !== activePlayer && downExistance[k_d] === inactivePlayer ){\r\n       updatedGameState[i_d][j_d] = activePlayer;\r\n       updatedGameStateTranspose[j_d][i_d] = activePlayer;\r\n       i_d++;\r\n       k_d++;\r\n     }\r\n    }\r\n\r\n\r\n    // color upward\r\n    let upExistance = [];\r\n    let i_u = rowIndex - 1 ;\r\n    let j_u = colIndex;\r\n    while (i_u >= 0){\r\n      upExistance.push(this.state.gameState[i_u][j_u])\r\n      i_u--;\r\n    }\r\n    \r\n    let blankAbove = upExistance.indexOf(blank) !== -1 ? true : false\r\n    let availableAbove = upExistance.indexOf(available) !== -1 ? true : false\r\n    let blankBeforeCurrentPlayer_u = upExistance.indexOf(blank) < upExistance.indexOf(activePlayer) ? true : false\r\n    let availableBeforeCurrentPlayer_u = upExistance.indexOf(available) < upExistance.indexOf(activePlayer) ? true : false\r\n    if ( blankAbove && blankBeforeCurrentPlayer_u ){\r\n      upExistance = [];\r\n    }\r\n    if ( availableAbove && availableBeforeCurrentPlayer_u ){\r\n      upExistance = [];\r\n    }\r\n    \r\n    if (upExistance.indexOf(activePlayer) !== -1){\r\n     let i_u = rowIndex - 1;\r\n     let j_u = colIndex;\r\n     let k_u = 0;\r\n     while (i_u >= 0 && upExistance[k_u] !== activePlayer && upExistance[k_u] === inactivePlayer){\r\n       updatedGameState[i_u][j_u] = activePlayer;\r\n       updatedGameStateTranspose[j_u][i_u] = activePlayer;\r\n       i_u--;\r\n       k_u++;\r\n     }\r\n    }\r\n\r\n    //color to the left\r\n    let leftExistance = [];\r\n    let i_l = rowIndex;\r\n    let j_l = colIndex - 1;\r\n    while (j_l >= 0){\r\n      leftExistance.push(updatedGameState[i_l][j_l])\r\n      j_l--;\r\n    }\r\n\r\n    let blankLeft = leftExistance.indexOf(blank) !== -1 ? true : false\r\n    let availableLeft = leftExistance.indexOf(available) !== -1 ? true : false\r\n    let blankBeforeCurrentPlayer_l = leftExistance.indexOf(blank) < leftExistance.indexOf(activePlayer) ? true : false\r\n    let availableBeforeCurrentPlayer_l = leftExistance.indexOf(available) < leftExistance.indexOf(activePlayer) ? true : false\r\n    if ( blankLeft && blankBeforeCurrentPlayer_l ){\r\n      leftExistance = [];\r\n    }\r\n    if ( availableLeft && availableBeforeCurrentPlayer_l ){\r\n      leftExistance = [];\r\n    }\r\n\r\n    if (leftExistance.indexOf(activePlayer) !== -1){\r\n     let i_l = rowIndex;\r\n     let j_l = colIndex - 1;\r\n     let k_l = 0;\r\n     while (j_l >= 0 && leftExistance[k_l] !== activePlayer && leftExistance[k_l] === inactivePlayer){\r\n       updatedGameState[i_l][j_l] = activePlayer;\r\n       updatedGameStateTranspose[j_l][i_l] = activePlayer;\r\n       j_l--;\r\n       k_l++;\r\n     }\r\n    }\r\n\r\n    // color to the right\r\n     let rightExistance = [];\r\n     let i_r = rowIndex;\r\n     let j_r = colIndex + 1;\r\n     while (j_r <= 7){\r\n       rightExistance.push(updatedGameState[i_r][j_r])\r\n       j_r++;\r\n     }\r\n\r\n     let blankRight = rightExistance.indexOf(blank) !== -1 ? true : false\r\n     let availableRight = rightExistance.indexOf(available) !== -1 ? true : false\r\n     let blankBeforeCurrentPlayer_r = rightExistance.indexOf(blank) < rightExistance.indexOf(activePlayer) ? true : false\r\n     let availableBeforeCurrentPlayer_r = rightExistance.indexOf(available) < rightExistance.indexOf(activePlayer) ? true : false\r\n     if ( blankRight && blankBeforeCurrentPlayer_r ){\r\n       rightExistance = [];\r\n     }\r\n     if ( availableRight && availableBeforeCurrentPlayer_r ){\r\n       rightExistance = [];\r\n     }\r\n\r\n\r\n     if (rightExistance.indexOf(activePlayer) !== -1){\r\n      let i_r = rowIndex;\r\n      let j_r = colIndex + 1;\r\n      let k_r = 0;\r\n      while (j_r <= 7 && rightExistance[k_r] !== activePlayer && rightExistance[k_r] === inactivePlayer){\r\n        updatedGameState[i_r][j_r] = activePlayer;\r\n        updatedGameStateTranspose[j_r][i_r] = activePlayer;\r\n        j_r++;\r\n        k_r++;\r\n      }\r\n     }\r\n\r\n     //check north west diagonal existance and color\r\n     let nwDiagonalExistance = [];\r\n     let i_nwd = rowIndex - 1;\r\n     let j_nwd = colIndex + 1;\r\n     while (i_nwd >= 0 && j_nwd <= 7){\r\n       nwDiagonalExistance.push(updatedGameState[i_nwd][j_nwd]);\r\n       i_nwd--;\r\n       j_nwd++;\r\n     }\r\n\r\n     let blankNW = nwDiagonalExistance.indexOf(blank) !== -1 ? true : false\r\n     let availableNW = nwDiagonalExistance.indexOf(available) !== -1 ? true : false\r\n     let blankBeforeCurrentPlayer_nw = nwDiagonalExistance.indexOf(blank) < nwDiagonalExistance.indexOf(activePlayer) ? true : false\r\n     let availableBeforeCurrentPlayer_nw = nwDiagonalExistance.indexOf(available) < nwDiagonalExistance.indexOf(activePlayer) ? true : false\r\n     if ( blankNW && blankBeforeCurrentPlayer_nw ){\r\n       nwDiagonalExistance = [];\r\n     }\r\n     if ( availableNW && availableBeforeCurrentPlayer_nw ){\r\n       nwDiagonalExistance = [];\r\n     }\r\n\r\n\r\n     if (nwDiagonalExistance.indexOf(activePlayer) !== -1){\r\n      let i_nwd = rowIndex - 1;\r\n      let j_nwd = colIndex + 1;\r\n      let k_nwd = 0;\r\n      while (i_nwd >= 0 && j_nwd <= 7 && nwDiagonalExistance[k_nwd] !== activePlayer && nwDiagonalExistance[k_nwd] === inactivePlayer){\r\n        updatedGameState[i_nwd][j_nwd] = activePlayer;\r\n        updatedGameStateTranspose[j_nwd][i_nwd] = activePlayer;\r\n        i_nwd--;\r\n        j_nwd++;\r\n        k_nwd++;\r\n      }\r\n     }\r\n\r\n      //check north east diagonal existance and color\r\n      let neDiagonalExistance = [];\r\n      let i_ned = rowIndex - 1;\r\n      let j_ned = colIndex - 1; \r\n      while (i_ned >= 0 && j_ned >= 0){\r\n        neDiagonalExistance.push(updatedGameState[i_ned][j_ned]);\r\n        i_ned--;\r\n        j_ned--;\r\n      }\r\n\r\n      let blankNE = neDiagonalExistance.indexOf(blank) !== -1 ? true : false\r\n      let availableNE = neDiagonalExistance.indexOf(available) !== -1 ? true : false\r\n      let blankBeforeCurrentPlayer_ne = neDiagonalExistance.indexOf(blank) < neDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      let availableBeforeCurrentPlayer_ne = neDiagonalExistance.indexOf(available) < neDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      if ( blankNE && blankBeforeCurrentPlayer_ne ){\r\n        neDiagonalExistance = [];\r\n      }\r\n      if ( availableNE && availableBeforeCurrentPlayer_ne ){\r\n        neDiagonalExistance = [];\r\n      }\r\n\r\n\r\n      if (neDiagonalExistance.indexOf(activePlayer) !== -1){\r\n        let i_ned = rowIndex - 1;\r\n        let j_ned = colIndex - 1;\r\n        let k_ned = 0;\r\n        while (i_ned >= 0 && j_ned >= 0 && neDiagonalExistance[k_ned] !== activePlayer && neDiagonalExistance[k_ned] === inactivePlayer){\r\n          updatedGameState[i_ned][j_ned] = activePlayer;\r\n          updatedGameStateTranspose[j_ned][i_ned] = activePlayer;\r\n          i_ned--;\r\n          j_ned--;\r\n          k_ned++;\r\n        }\r\n      }\r\n    \r\n      //check south east diagonal existance and color\r\n      let seDiagonalExistance = [];\r\n      let i_sed = rowIndex + 1;\r\n      let j_sed = colIndex + 1;\r\n      while (i_sed <= 7 && j_sed <= 7){\r\n        seDiagonalExistance.push(updatedGameState[i_sed][j_sed]);\r\n        i_sed++;\r\n        j_sed++;\r\n      }\r\n\r\n\r\n      let blankSE = seDiagonalExistance.indexOf(blank) !== -1 ? true : false\r\n      let availableSE = seDiagonalExistance.indexOf(available) !== -1 ? true : false\r\n      let blankBeforeCurrentPlayer_se = seDiagonalExistance.indexOf(blank) < seDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      let availableBeforeCurrentPlayer_se = seDiagonalExistance.indexOf(available) < seDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      if ( blankSE && blankBeforeCurrentPlayer_se ){\r\n        seDiagonalExistance = [];\r\n      }\r\n      if ( availableSE && availableBeforeCurrentPlayer_se ){\r\n        seDiagonalExistance = [];\r\n      }\r\n\r\n\r\n      if (seDiagonalExistance.indexOf(activePlayer) !== -1){\r\n        let i_sed = rowIndex + 1;\r\n        let j_sed = colIndex + 1;\r\n        let k_sed = 0;\r\n        while (i_sed <= 7 && j_sed <= 7 && seDiagonalExistance[k_sed] !== activePlayer && seDiagonalExistance[k_sed] === inactivePlayer){\r\n          updatedGameState[i_sed][j_sed] = activePlayer;\r\n          updatedGameStateTranspose[j_sed][i_sed] = activePlayer;\r\n          i_sed++;\r\n          j_sed++;\r\n          k_sed++;\r\n        }\r\n      }\r\n  \r\n      //check south west diagonal existance and color\r\n      let swDiagonalExistance = [];\r\n      let i_swd = rowIndex + 1;\r\n      let j_swd = colIndex - 1;\r\n      while (i_swd <= 7 && j_swd >= 0){\r\n        swDiagonalExistance.push(updatedGameState[i_swd][j_swd]);\r\n        i_swd++;\r\n        j_swd--;\r\n      }\r\n\r\n\r\n      let blankSW = swDiagonalExistance.indexOf(blank) !== -1 ? true : false\r\n      let availableSW = swDiagonalExistance.indexOf(available) !== -1 ? true : false\r\n      let blankBeforeCurrentPlayer_sw = swDiagonalExistance.indexOf(blank) < swDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      let availableBeforeCurrentPlayer_sw = swDiagonalExistance.indexOf(available) < swDiagonalExistance.indexOf(activePlayer) ? true : false\r\n      if ( blankSW && blankBeforeCurrentPlayer_sw ){\r\n        swDiagonalExistance = [];\r\n      }\r\n      if ( availableSW && availableBeforeCurrentPlayer_sw ){\r\n        swDiagonalExistance = [];\r\n      }\r\n\r\n\r\n      if (swDiagonalExistance.indexOf(activePlayer) !== -1){\r\n        let i_swd = rowIndex + 1;\r\n        let j_swd = colIndex - 1;\r\n        let k_swd = 0;\r\n        while (i_swd <= 7 && j_swd >= 0 && swDiagonalExistance[k_swd] !== activePlayer && swDiagonalExistance[k_swd] === inactivePlayer){\r\n          updatedGameState[i_swd][j_swd] = activePlayer;\r\n          updatedGameStateTranspose[j_swd][i_swd] = activePlayer;\r\n          i_swd++;\r\n          j_swd--;\r\n          k_swd++;\r\n        }\r\n      }\r\n\r\n\r\n     //Set the clicked block to whichever player clicked it.\r\n      updatedGameState[rowIndex][colIndex] = activePlayer;\r\n      updatedGameStateTranspose[colIndex][rowIndex] = activePlayer;\r\n\r\n\r\n     //Remove tiles that were previously labeled as available\r\n     updatedGameState = updatedGameState.map(i => i.map(j => j === available ? j = 0 : j))\r\n     updatedGameStateTranspose = updatedGameStateTranspose.map(i => i.map(j => j === available ? j = 0 : j))\r\n\r\n     let tempGameState = updatedGameState\r\n     let tempGameStateTranspose = updatedGameStateTranspose\r\n     //Determine valid tiles surrounding the current player (currently excluding edge cases)\r\n     updatedGameState = updatedGameState.map((i, index_i) => {\r\n       return(\r\n          i.map((j, index_j) => {\r\n            \r\n            return(\r\n              (j === blank || j === available) &&\r\n              ( this.checkTileOnRight(index_i, index_j, activePlayer, tempGameState) || this.checkTileOnLeft(index_i, index_j, activePlayer, tempGameState) || \r\n               this.checkTileAbove(index_i, index_j, activePlayer, tempGameStateTranspose) || this.checkTileBelow(index_i, index_j, activePlayer, tempGameStateTranspose) || \r\n               this.checkNorthEast(index_i, index_j, activePlayer, tempGameState) || this.checkNorthWest(index_i, index_j, activePlayer, tempGameState) ||\r\n               this.checkSouthEast(index_i, index_j, activePlayer, tempGameState) || this.checkSouthWest(index_i, index_j, activePlayer, tempGameState) ) ? \r\n              j = 8 : j\r\n              )\r\n          })\r\n       ) \r\n      })\r\n\r\n      for (let i = 0; i < updatedGameStateTranspose.length; i++){\r\n        for (let j = 0; j < updatedGameStateTranspose[i].length; j++){\r\n          updatedGameStateTranspose[i][j] = updatedGameState[j][i];\r\n        }\r\n      }\r\n    \r\n     let scoreOfState = this.updateScore(gameState)\r\n     let result = {gameState: updatedGameState, gameStateTranspose: updatedGameStateTranspose, activePlayer: activePlayer, scoreOfState: scoreOfState};\r\n  \r\n\r\n     return result\r\n  }\r\n\r\n  updateState(updatedGameState, updatedGameStateTranspose, activePlayer){\r\n    let newScore = this.updateScore(updatedGameState)\r\n    this.checkForWin(newScore.blackPoints, newScore.whitePoints, newScore.availablePoints)\r\n    this.setState({gameState: updatedGameState, \r\n                   gameStateTranspose: updatedGameStateTranspose,\r\n                   blackPoints: newScore.blackPoints,\r\n                   whitePoints: newScore.whitePoints,\r\n                   availablePoints: newScore.availablePoints})\r\n    this.setPlayer(activePlayer);\r\n  }\r\n\r\n  createGameBoard(gameState){\r\n    let result = gameState.map((i, rowIndex) => {\r\n    \r\n      return(\r\n          <Row className = 'myrow' key = {rowIndex}>\r\n            {i.map((j, colIndex) => {\r\n              return(\r\n                <Tile \r\n                  key = {colIndex}\r\n                  tileValue = {j} \r\n                  handleGameState = {this.handleGameState}\r\n                  rowIndex = {rowIndex} \r\n                  colIndex = {colIndex} \r\n                  activePlayer = {this.state.activePlayer}\r\n                  handleAI = {this.handleAI}\r\n                  gameMode = {this.state.gameMode}\r\n                  gameState = {this.state.gameState}\r\n                  gameStateTranspose = {this.state.gameStateTranspose}\r\n                  updateState = {this.updateState}\r\n                  black = {black}\r\n                  white = {white}\r\n                  available = {available}\r\n                  humanIsBlack = {this.state.humanIsBlack}\r\n                  updateMovesSoFar = {this.updateMovesSoFar}\r\n\r\n              \r\n                  />\r\n              )\r\n              })\r\n            }\r\n          </Row>\r\n        )\r\n      })\r\n\r\n      return result\r\n  }\r\n  \r\n  toggleColor(){\r\n    this.setState({humanIsBlack: !this.state.humanIsBlack})\r\n  }\r\n\r\n  toggleDebug(){\r\n    this.setState({debugMode: !this.state.debugMode})\r\n  }\r\n\r\n  togglePruning(){\r\n    this.setState({pruning: !this.state.pruning})\r\n  }\r\n\r\n  toggleProgramTrace(){\r\n    this.setState({programTrace: !this.state.programTrace})\r\n  }\r\n\r\n  handleDepth(depth){\r\n    this.setState({aiDepth: depth})\r\n  }\r\n\r\n  handleDebugDepth(change){\r\n    let depth = this.state.debugDepth + change;\r\n    this.setState({debugDepth: depth})\r\n  }\r\n\r\n\r\n\r\n  render(){\r\n\r\n    let gameInfo = {  \r\n                      gameState: this.state.gameState, \r\n                      gameStateTranspose: this.state.gameStateTranspose, \r\n                      activePlayer: this.state.activePlayer, \r\n                      scoreOfState: \r\n                        {\r\n                          blackPoints: this.state.blackPoints, \r\n                          whitePoints: this.state.whitePoints, \r\n                          availablePoints: this.state.availablePoints\r\n                        }\r\n                    }\r\n    \r\n    let allMoves = <Row style={{margin: '20px'}}>\r\n                        <Col xs = {12}>\r\n                        <h5>Game Trace</h5>\r\n                        {movesSoFar.map((item) => {    \r\n                            return(                 \r\n                            <div style = {{width: '400px', height: '400px', margin: '2em 2em', float: 'left'}}>{item}</div>\r\n                            )\r\n                            }\r\n                        )\r\n                        }\r\n\r\n                        </Col>\r\n                    </Row>\r\n          \r\n    \r\n\r\n    let gameMode = (this.state.gameMode === 'menu' ? \r\n                    <Container className = 'gamecontainer'>\r\n                        <h3>Choose A Mode:</h3>\r\n                        <button onClick={this.handleGameMode.bind(this, '2playergame')}>Human v. Human</button>\r\n                        <button onClick={this.handleGameMode.bind(this, 'aigame')}>Human v. AI</button>\r\n                    </Container> :\r\n                    <div className = 'gamecontainer'>\r\n                      \r\n                      <div className = 'gameboard' style={{display: 'inline-block'}}\r\n                      onTransitionEnd={this.state.gameMode === 'aigame' && this.state.activePlayer === white ? this.handleAI.bind(this, gameInfo) : null}\r\n                         >\r\n                        {this.createGameBoard(this.state.gameState)}   \r\n          \r\n                      </div>\r\n                     \r\n                      \r\n                        <h4>{this.state.activePlayer === black ? 'Player 1' : 'Player 2'}'s Turn</h4> \r\n                        <div>\r\n                          <h5>Score for Player 1:</h5>\r\n                          <p>{this.state.blackPoints}</p>\r\n                        </div>\r\n                        <div>\r\n                          <h5>Score for Player 2:</h5>\r\n                          <p>{this.state.whitePoints}</p>\r\n                        </div>\r\n \r\n                        {this.state.gameMode === 'gameover' ? \r\n                         <div style={{position: 'absolute', top: '215px', left: '180px', width: '200px', backgroundColor: 'rgba(200,200,200,0.9)', textAlign: 'center', padding: '15px', color: 'black'}}>\r\n                              <h5>Game Over <br /> {this.state.blackPoints === this.state.whitePoints ? \r\n                              'Tie Game' : (this.state.blackPoints > this.state.whitePoints ? 'Black Wins' : 'White Wins')} </h5> \r\n                        </div> : null }\r\n                      </div>\r\n                      )\r\n    let settings = <Container>\r\n                    <h4>Settings</h4>\r\n                    <h6 style={{marginTop: '1em'}}>Choose your color:</h6>\r\n                    <Button variant={this.state.humanIsBlack ? 'dark' : 'light'} onClick = {this.toggleColor}>Toggle Color</Button>\r\n                    <h6 style={{marginTop: '1em'}}>Current Game Trace</h6>\r\n                    <Form>\r\n                      <Form.Check \r\n                        onClick={this.toggleProgramTrace}\r\n                        type=\"switch\"\r\n                        id=\"trace-switch\"\r\n                        label= {this.state.programTrace ? \"On\" : \"Off\"}\r\n                      />\r\n                    </Form>\r\n                    <h6 style={{marginTop: '1em'}}>Debug Mode</h6>\r\n                    <Form>\r\n                      <Form.Check \r\n                        onClick={this.toggleDebug}\r\n                        type=\"switch\"\r\n                        id=\"debug-switch\"\r\n                        label= {this.state.debugMode ? \"On\" : \"Off\"}\r\n                      />\r\n                    </Form>\r\n                    <h6 style={{marginTop: '1em'}}>Cheat</h6>\r\n                    <Button variant = \"primary\" onClick={this.handleAI.bind(this, gameInfo)}>Click for an AI play</Button>\r\n                    <h6 style={{marginTop: '1em'}}>Alpha Beta Pruning</h6>\r\n                    <Form>\r\n                      <Form.Check \r\n                        onClick={this.togglePruning}\r\n                        type=\"switch\"\r\n                        id=\"pruning-switch\"\r\n                        label= {this.state.pruning ? \"On\" : \"Off\"}\r\n                      />\r\n                    </Form>\r\n                 \r\n                  <h6 style={{marginTop: '1em'}}>Depth</h6>\r\n                  <Form>\r\n                    <Form.Check\r\n                        defaultChecked\r\n                        custom\r\n                        type=\"radio\"\r\n                        label=\"2\"\r\n                        name=\"formHorizontalRadios\"\r\n                        id=\"formHorizontalRadios1\"\r\n                        onClick = {this.handleDepth.bind(this, 3)}\r\n                      />\r\n                      <Form.Check\r\n                        custom\r\n                        type=\"radio\"\r\n                        label=\"4\"\r\n                        name=\"formHorizontalRadios\"\r\n                        id=\"formHorizontalRadios2\"\r\n                        onClick = {this.handleDepth.bind(this, 5)}\r\n                      />\r\n                      <Form.Check\r\n                        custom\r\n                        type=\"radio\"\r\n                        label=\"6\"\r\n                        name=\"formHorizontalRadios\"\r\n                        id=\"formHorizontalRadios3\"\r\n                        onClick = {this.handleDepth.bind(this, 7)}\r\n                      />\r\n                      <Form.Check\r\n                        custom\r\n                        type=\"radio\"\r\n                        label=\"8\"\r\n                        name=\"formHorizontalRadios\"\r\n                        id=\"formHorizontalRadios4\"\r\n                        onClick = {this.handleDepth.bind(this, 9)}\r\n                      />\r\n                  </Form>\r\n                  </Container>\r\n\r\n\r\n    let debugMode2 = <div style={{margin: '50px'}} >\r\n                      <h4>Debug Mode</h4>\r\n                    \r\n\r\n                      {this.state.debugDepth !== undefined ? \r\n                        <div>\r\n                          <p>\r\n                          {this.state.debugDepth !== this.state.aiDepth ? <button onClick = {this.handleDebugDepth.bind(this, 1)}>Go Up One Level</button> : null}\r\n                          {this.state.debugDepth !== 0 ? <button onClick = {this.handleDebugDepth.bind(this, -1)}>Go Down One Level</button> : null}\r\n                        </p>\r\n                        <p>Level {this.state.debugDepth}</p> \r\n                        </div> : \r\n                        null\r\n                \r\n                      }\r\n                      \r\n                      <Row>\r\n                        <Col xs = {12}>\r\n                        {possibleMoves.map((item, index) => {                        \r\n                          if (item.depth === this.state.debugDepth){\r\n                            \r\n                          return(\r\n                            <div style = {{width: '400px', height: '400px', margin: '2em 2em', float: 'left'}}>{item.board}Depth: {item.depth}; Score: {item.score}</div>\r\n                            )\r\n                   \r\n                          }\r\n                          else{\r\n                            return(\r\n                              null\r\n                            )\r\n                          }\r\n                        \r\n\r\n                 \r\n                      }\r\n                        )\r\n                      }\r\n                       \r\n                        </Col>\r\n                      </Row>\r\n                     \r\n                      <Row style={{border: '1px solid black'}}>\r\n                      <Col xs = {12}>\r\n                      {this.state.pruning ? <h5>Prunes:</h5> : null}\r\n                      {prunes.map(item => {\r\n                        if (item.depth-1 === this.state.debugDepth){\r\n                          return(\r\n                            <div style = {{width: '400px', height: '400px', margin: '2em 2em', float: 'left'}}>{item.board}Depth: {item.depth-1}; </div>\r\n                          )\r\n                          \r\n                        }\r\n                        else{\r\n                          return(\r\n                            null\r\n                          )\r\n                        }\r\n                      }\r\n                      )}\r\n                      </Col>\r\n                      </Row>\r\n                      \r\n                    </div>\r\n\r\n  \r\n          \r\n  \r\n    return(\r\n      <React.Fragment>\r\n      <Row>\r\n        <Col className = 'settings' xs  = {3}>{this.state.gameMode === '2playergame' || this.state.gameMode === 'aigame' ? settings : null}</Col>\r\n        <Col className = 'gameMode' xs = {4}>{gameMode}</Col>\r\n      </Row>\r\n        {this.state.programTrace ? <Row style = {{marginTop: '200px'}}><Col className = 'debug'>{allMoves}</Col></Row> : null}\r\n        {this.state.debugMode ? <Row style = {{marginTop: '200px'}}><Col className = 'debug'>{debugMode2}</Col></Row> : null}\r\n      </React.Fragment> \r\n    )\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}